[ { "title": "Brute Force", "url": "/posts/BruteForce/", "categories": "Web", "tags": "Brute Force, Web Hacking", "date": "2022-09-13 00:00:00 +0000", "snippet": "Brute Force 이란?영어로 Brute 는 “짐승 같은,난폭한”이라는 뜻이고, Brute Force는 “난폭한 힘,폭력”이라는 뜻으로 조합 가능한 모든 문자열을 하나씩 대입하여 암호를 해독하는 방법이다.Brute Force 장점이론적으로 가능한 모든 경우의 수를 다 검색해 보는 것이라 정확도 100%가 항상 보장된다. 또한 브루트 포스의 특 장점은 거의 완벽하게 병렬작업이 가능하다는 점 이다. 이 때문에 병렬 프로그래밍 기법을 사용하거나, GPGPU를 이용하기도 하며, 여러 대의 컴퓨터를 연결해서 동시에 작업할 수도 있다. 이렇게 하면 투자 자원에 비례해서 문제 해결하는 시간을 줄일 수 있다.Brute Force 단점브루트 포스에는 치명적인 단점이 있다. 보통 비밀번호로 자주 쓰이는 자릿수가 최대 8자리인 영문 대소문자, 숫자를 충족하는 사전파일을 만들면 그 텍스트 파일의 용량은 34^8바이트이며, 이것을 GB로 환산해보면 대략 1663GB가 나온다. 조합 가능한 모든 문자열을 대입하기 때문에 아무리 컴퓨터가 빠르다고 하더라도 시간이 매우 많이 걸린다. 당장 영문 소문자 + 숫자 조합만 쳐도 n자리 암호를 뚫는 데에는 36^n의 시간이 걸린다. 즉 10 글자만 되어도 36^10 = 3,656,158,440,062,976 가지가 된다. 이 정도면 쉬운 암호 알고리즘이라 해도 초당 1억 번 계산 기준 대충 14개월 걸리는 수준이다.물론 암호가 더 복잡하거나 길이가 더 길어지면 수백 ~ 수천 년은 기본으로 기다려야 한다.Brute Force 공격예시아래아 한글, MS워드 등 현대에 많이 쓰는 문서 포맷은 데이터를 모두 암호화했기 때문에 헥스 에디터로 뜯어도 암호를 통과하는 방법 따위는 존재하지 않고, 암호를 하나씩 대입해서 풀어보는 것 이외에는 우회 방법 따위는 존재하지 않는다. 따라서 이런 파일의 암호를 풀어주는 간단한 프로그램들은 그냥 브루트 포스를 구핸하는 프로그램으로 봐도 무방하며, 해커들이 웹페이지에 로그인을 시도할 때에도 자주 사용된다Python 으로 Brute Force 구현하기Webhacking.kr 4번 문제가 Brute Force를 사용하여 해결하는 문제이기 때문에 Webhacking.kr 4번 문제를 이용하여 구현해 보자4번 문제를 들어가면 이런식으로 문자열이 나오는데 이것을 보고 sha-1로 암호화 되어있다는 것을 알수 있다.3번째 줄을 보면 ,chall4라는 세션값이 존재하고 만약 사용자로부터 POST형식으로 전송받은 KEY값이 세션의 chall4와 일치하면 문제가 풀린다는 것을 알 수 있다.4번째 줄에 의해, $hash 값은 10000000 ~ 99999999 사이의 숫자 뒤에 ‘salt_for_you’를 붙인 문자열이 된다.6번째 줄에서는 $hash를 sha1해시 함수를 사용하여 500번 암호화 시켰다는것을 알수 있다.스레드를 이용하여 시간을 단축 시키고 범위 id와 계산 범위를 지정해준뒤 def work로 넘겨주면1 ~ 20 까지의 파일을 생성하고 그 파일에 계산값에 salt_for_you를 붙인뒤 sha1로 500번 복호화 한 값이 1 ~ 20 파일 안에 저장이 된다.이런식으로 파일이 만들어지고 이 안에 결과 값이 저장이 되면 파일을 열어 검색기능으로 처음 나온 문자열과 같은 문자열을 찾아 해결할수 있다.Brute Force 대응방안 암호는 최소 10자리 이상을 사용하자. 암호가 12자리를 넘어간다면 슈퍼컴퓨터를 가져와도 안전하다. 숫자만으로 이러어져 있다 해도 암호 한 자리당 경우의 수가 10배씩 늘어난다. 12자리면 10^12이며 영문 대소문자 섞은 12자리라면 경우의 수는 62^12 = 3226266762400000000000가 된다. 특수 문자를 사용하자 CAPTCHA를 사용한다. Brute Force를 우리가 비밀번호를 여러번 틀리면 CAPTCHA를 사용하여 사람인지 확인 하는것 처럼 Brute Force를 막기 위해 비밀번호가 연속적으로 틀리게 된다면 CAPTCHA를 사용하여 Brute Force를 막을수 있다." }, { "title": "About_SCP", "url": "/posts/About_SCP/", "categories": "Notice", "tags": "scp, promotion", "date": "2022-09-06 00:00:00 +0000", "snippet": "About_SCP소개말중부대학교 SCP 동아리는 정보보호학과 유승재 교수님의 지도하의 정보보호 연구 동아리입니다. 1998년 정보보호 창업 동아리 Soul Magic으로 창설해, 2005년 Security Check Point의 약자인 S.C.P로 바꾸어 활동하고 있습니다. S.C.P는 중부대학교 고양캠퍼스 세종관 804호에 위치하고 있으며 동아리 회원들 간에 친목도모는 물론 능률적이고 효율적인 학습을 위해 노력하고 있습니다. 2000년도 KISA 1회 대학동아리 지원 사업에 선정되며 2019년까지 꾸준히 KUCIS에 몸담아 활동한 바 있습니다.어떤 활동을 하나요?동아리 내부 세미나가장 기초가 되는 활동은 동아리 내부세미나 입니다.각자 공부해온 내용을 바탕으로 정기적인 내부 세미나를 진행합니다.멘토링 활동1학년 및 2학년을 대상으로 C언어, 파이썬, 리눅스 멘토링을 진행합니다.멘토링을 통해 프로그래밍 언어와 보안에 대한 기초공부를 할 수 있습니다.JBU-CTF 운영2019, 2020, 2022년도에 중부대학교 정보보호학과가 주최 및 S.C.P가 주관하여 CTF를 운영하였습니다.Web, Reversing, Crypto, Forensic, Pwnable, Network, Misc 총 7개 분야의 문제를 직접 출제하고 있습니다.위 활동 이외에도 외부세미나, 프로젝트, 교내 비교과 프로그램, 외부 대회 참여와 같은 다양한 활동을 진행하고 있습니다.임원진 소개현재 임원진은 총 5명으로,이다영 - 회장유재겸 - 부회장이정호 - 총무서민재 - 학습부장신재형 - 홍보부장으로 이루어져 있습니다.활동내역2023년26th Hacking Camp CTF 우승팀 - 송태현2022년Best Of the Best 11기 합격 - 이예준, 임성빈POC 2022 이벤트 부스 운영CCA(Cyber-security Club Association) 가입 및 임원진 활동BOB총동문회 MOU협약 체결HSpace 파트너십 체결안랩, 토스 기업 방문 및 견학동아리 내부 해커톤S.C.P 오픈 세미나제3회 JBU-CTF 문제출제 및 운영24th Hacking Camp 발표 - 노무승2022 사이버가디언즈 콘퍼런스 발표 - 노무승CCA 겨울 화이트햇 세미나 발표 - 유재겸한국통신학회 동계종합학술발표회 논문 투고 - 서민재, 유재겸25th Hacking Camp CTF 우승팀 - 김우종중부대학교 캡스톤디자인 아이템경진대회 입선 - 이다영한국융합보안학회 하계학술대회 우수논문상 - 이다영한국융합보안학회 융합보안캡스톤대회 우수상 - 이다영, 노무승한국해양대학교 조선·해운 빅데이터 활용 아이디어 공모전 아이디어상 - 이다영, 노무승중부대학교 2022 JBU CTF 대회 운영 공로상 - 노무승, 서민재, 신재형, 유재겸, 이다영중부대학교 4차산업혁명시대 개인정보보호 정책 및 기술 아이디어 공모전 최우수상 - 노무승, 신재형, 심재훈, 이다영2022 제8회 디지털 범인을 찾아라 경진대회 장려상 - 전유민010 Editer Jumplist (automatic, custom) 템플릿 승인 및 등록 - 이유경, 장혜선2021년Best Of the Best 10기 합격 - 김우종, 서민재, 이다영, 유재겸중부대학교 캡스톤디자인 경진대회 입선 - 조재현중부대학교 2021 JBU CTF 최우수상 - 장혜선, 노무승중부대학교 2021 JBU CTF 우수상 - 전유민, 서동훈, 김우종, 이유경, 서민재, 이지훈중부대학교 캡스톤 디자인 아이템 경진대회 우수상 - 조재현정보보호학회 호남지부 추계학술대회 장려상 - 서동훈, 전유민, 장혜선, 이유경Incognito 프로젝트 참여 - 서동훈, 노무승한국융합보안학회 하계학술대회 및 융합 보안 캡스톤 대회 최우수상 - 김현진, 조재현, 허송이보안 연합컨퍼런스 Incognito 활동HSPACE Open CTF 문제 출제 - 전유민N0Named 2nd webinar 발표 - 전유민TeamH4C 학생용 해킹노트 컨퍼런스 발표 - 김우종, 노무승Incognito 2021 해킹 컨퍼런스 발표 - 서동훈2021 한국정보보호학회 호남지부 추계학술대회 논문 투고 - 서동훈, 전유민, 이유경, 장혜선한국정보보호학회 동계학술대회 논문투고 - 유재겸2020년SOFTWARE MAESTRO 11기 합격 - 양경모Best Of the Best 9기 합격 - 서동훈, 우제혁, 전유민, 노무승Best Of the Best 9기 PL - 조재현중부대학교 2020 JBU CTF 대회 운영 공로상 - 조재현, 김현진, 허송이, 김우종, 문승재, 이유경중부대학교 CCIT 프로젝트 우수상 - 조재현중부대학교 2020 취업동아리 우수상정보보호학회 호남지부 동계학술대회 우수논문상 - 김현진, 조재현, 허송이토스 기업 방문 및 견학Team H4C 팀원 활동 - 김우종정보보호학회 동계학술대회 논문 투고 및 발표 - 조재현정보보호학회 호남지부 동계학술대회 투고 - 김현진, 조재현, 허송이한국디지털포렌식학회 동계학술대회 논문 투고 및 발표 - 전유민2019년Best Of the Best 8기 합격 - 조재현KISA 정보보호 우수 동아리 선정중부대학교 해킹방어대회 운영 표창장 - 정재훈, 박지윤, 서동훈, 전유민중부대학교 학생 보안 전문요원 위촉장 - 표상영한국저작권보호원 디지털 포렌식 논문,아이디어 &amp;amp; 콘텐츠 공모전 우수상 - 조재현19th Hacking Camp 운영진 - 이정모Zer0Con 2019 운영진 - 이정모POC 2019 운영진 - 이정모경기도 교육청 꿈의 대학 - 정재훈, 양경모,서동훈, 전유민, 박지윤, 조재현, 황선홍서경강 KUCIS 학술 세미나 발표 - 서동훈, 전유민, 조재현한국정보보호학회 동계학술대회 발표 - 황선홍2018년중부대학교 학생 보안 전문요원 위촉장 - 이정모, 배대식중부대학교 정보시스템 보안 취약점 발견 활동 표창장 - 배대식뉴비 해킹대회 Open CTF 입상(5위) - 배대식18th Hacking Camp CTF SINCERE HACKER - 황선홍18th Hacking Camp CTF BEST HACKER - 표상영CodeGate 2018 해킹 시연 공모전 장려상 - 표상영, 정재훈, 황선홍17th,18th Hacking Camp 운영진 - 이정모CodeEngn 운영진 - 장한빈, 황선홍POC 2018 운영진 - 이정모, 배대식, 황선홍, 박지윤ZeroC0n 운영진 - 이정모경기도 교육청 진로캠프 발표 - 이정모경기도 교육청 꿈의 대학 발표 - 이정모, 배대식, 황선홍, 정재훈, 박지윤서경강 KUCIS 학술 세미나 발표 - 이정모중부대,인하대,성신여대 연합 세미나 발표 - 이정모충청 KUCIS 학술 세미나 발표 - 장한빈호남 KUCIS 학술 세미나 발표 - 정영호익산 대진고등학교 재능기부 -황선홍, 전유민, 정재훈" }, { "title": "스택(Stack)과 스택 프레임(Stack Frame)", "url": "/posts/Stack_Frame/", "categories": "Reversing", "tags": "stack, stack frame", "date": "2022-08-28 00:00:00 +0000", "snippet": "스택(Stack)스택(Stack)의 개념LIFO(Last In First Out) 또는 FILO(First In Last Out) 형태로 동작하는 선형 자료 구조스택(Stack)의 사전적 의미는 “더미”, “쌓다”로 자료 구조의 스택도 데이터를 순차적으로 나열한 구조이다.가장 최근에 보관한 자료를 꺼내는 방식으로 동작한다.스택의 연산은 Push와 Pop이 있다.Push는 삽입 연산으로 가장 위에 원소를 추가하고, Pop은 삭제 연산으로 가장 위의 원소를 반환한다.Top은 스택의 맨 위에 위치해 있는 원소를 가리킨다.Push와 Pop은 Top으로 지정된 곳에서만 가능하다.따라서 스택의 접근(Push와 Pop)은 한 곳(Top)에서만 일어난다.스택의 예시로는 아래와 같이 접시를 쌓았을 때 맨 위의 제일 마지막으로 쌓은 접시부터 쓰게 되는 것을 생각하면 이해하기 쉽다.스택(Stack)의 특징 제일 위의 데이터만 알 수 있다. 스택이 담을 수 있는 크기를 초과하여 자료를 Push 하면 스택 오버플로우(Stack Overflow)가 발생한다. 스택이 비었을 때 Pop을 하면 스택 언더플로우(Stack Underflow)가 발생한다.스택(Stack)의 활용 사례※ 주로 왔던 길을 되돌아갈 때 유용 웹 브라우저의 뒤로 가기 문서 작업의 Ctrl + z (Undo) 역순 문자열 생성 후위 표기법 계산 함수 호출 시 복귀 저장 재귀 함수 호출 시 복귀 저장스택의 연산 push(item) : 스택에 데이터(item) 추가 pop() : 스택의 맨 위 원소를 제거하고 반환 peek() / top() : 스택의 맨 위의 값을 반환 (제거하지 않음) clear() : 스택 안 모든 값 강제 초기화 혹은 비어있는지 여부 확인 empty() / isEmptyStack() : 스택이 비어있는지 여부 확인 (비어있다면 True, 비어있지 않다면 False) full() / isFullStack() : 스택이 가득 찼는지 여부 확인 (차 있다면 True, 차있지 않다면 False) size() : 현재 스택에 들어있는 원소의 개수 반환 (크기 확인)Python으로 스택 구현하기ADT Stack ADT(Abstract Data Type) 란?프로그래밍 언어에서 사용되는 데이터형을 정의함에 있어서 그 데이터형에 적용 가능한 연산 형식과 제약 조건 등만을 보여주고 실제로 그 연산이 어떻게 구체적으로 표현되어 있는지는 알 수 없게 하는 기능.출처 : 추상 데이터형 [abstract data type, 抽象-型] (컴퓨터인터넷IT용어대사전, 전산용어사전편찬위원회) → 간단히 말해, 구현 방법은 알리지 않고 실제 기능이나 형식(e.g. 함수)을 정의해 놓은 것. push(item) : 스택에 데이터(item) 추가 pop() : 스택 맨 위 원소를 제거하고 반환 peek() : 스택의 맨 위의 값을 반환 (제거하지 않음) clear() : 스택 안 모든 값 강제 초기화 isEmptyStack() : 스택이 비어있는지 여부 확인 (비어있다면 True, 비어있지 않다면 False) isFullStack() : 스택이 가득 찼는지 여부 확인 (차 있다면 True, 차있지 않다면 False) size() : 현재 스택에 들어있는 원소의 개수 반환 (크기 확인) display() : top 위치에 있는 원소부터 차례대로 출력스택 구현하기 - 부분 설명1. 클래스 생성과 __init__class STACK: def __init__(self, max_size=5): self.stack = [] self.top = -1 self.max = max_size-1STACK이라는 클래스를 생성해주었다.__init__ 함수 원소를 넣어줄 리스트 생성이 리스트가 원소가 들어갈 스택 역할을 하는 것이다. top 변수를 선언해준다.top가 -1인 이유는 스택이 비어있는 상태로 설정해주기 위함이고, 리스트는 0번지부터 시작하기 때문이다. 스택의 최대 크기를 정해준다.위에서 max_size를 정해주었는데, 이는 5개의 원소를 넣을 수 있다는 의미로 정해주었다.max_size-1을 해준 이유는 첫 번째 원소의 인덱스 값이 0이기 때문에 총 5칸을 만들어주기 위함이다.2. isEmptyStack()과 isFullStack() def isEmptyStack(self): if self.top == -1: return True else: return False def isFullStack(self): if self.top == self.max: return True else: return Falsepush와 pop을 해주기 위해서는 먼저 스택이 완전히 비워져 있는지, 혹은 꽉 차있는 지를 알아야 한다.따라서 스택의 상태를 검사해줄 함수 isEmptyStack()과 isFullStack()을 먼저 선언해줄 것이다.isEmptyStack 함수 만약 top이 -1(스택이 완전히 비워져 있음)이라면 True를 반환하고, 아니라면 False를 반환해준다.isFullStack 함수 만약 top이 스택의 최대 크기와 일치(스택이 완전히 차있음)한다면 True를 반환하고, 아니라면 False를 반환해준다.3. peek() def peek(self): if self.isEmptyStack() == True: print(&quot;Stack is empty.&quot;) else: return self.stack[self.top]먼저, 스택이 비어있는지 검사해주어 비어있다면 “Stack is empty.”라는 메시지를 띄워준다.비어있지 않다면 스택 맨 위의 값인 top을 반환해준다.4. clear() def clear(self): self.stack = [] self.top = -1stack 변수를 다시 빈 리스트로 선언해주고, top의 값도 -1로 저장해준다.5. size() def size(self): return len(self.stack)len()을 이용해 스택의 크기를 반환해준다.6. display() def display(self): for a in reversed(self.stack): print(a)스택 안 값들을 top을 기준으로 출력해준다. (top을 제일 먼저 출력)7. push() def push(self, item): if self.isFullStack() == True: print(&quot;Stack is full.&quot;) else: self.stack.append(item) self.top += 1스택이 가득 차 있는지 검사를 해주고 가득 차 있다면 “Stack is full”을 출력해준다.가득 차 있지 않다면 stack 안에 item 인자 값을 추가해주고, top의 위치를 1 증가시켜준다.8. pop() def pop(self): if self.isEmptyStack() == True: print(&quot;Stack is empty.&quot;) else: pop_item = self.stack[self.top] del self.stack[self.top] self.top -= 1 return pop_item스택이 비어있는지 검사를 해주고 비어있다면 “Stack is empty.”를 출력해준다.완전히 비어있지 않다면 pop_item 변수에 스택의 가장 위 원소를 저장해주고, 그 값을 스택에서 삭제해준다.top의 위치 값도 1 감소시켜준다.마지막으로 pop_item(스택 맨 위의 값)을 반환해준다.전체 코드class STACK: def __init__(self, max_size=5): self.stack = [] self.top = -1 self.max = max_size-1 def isEmptyStack(self): if self.top == -1: return True else: return False def isFullStack(self): if self.top == self.max: return True else: return False def peek(self): if self.isEmptyStack() == True: print(&quot;Stack is empty.&quot;) else: return self.stack[self.top] def clear(self): self.stack = [] self.top = -1 def size(self): return len(self.stack) def display(self): for a in reversed(self.stack): print(a) def push(self, item): if self.isFullStack() == True: print(&quot;Stack is full.&quot;) else: self.stack.append(item) self.top += 1 def pop(self): if self.isEmptyStack() == True: print(&quot;Stack is empty.&quot;) else: pop_item = self.stack[self.top] del self.stack[self.top] self.top -= 1 return pop_item스택 프레임(Stack Frame)스택 프레임(Stack Frame)이란?ESP(스택 포인터)가 아닌 EBP(베이스 포인터) 레지스터를 사용하여스택 내의 로컬 변수, 파라미터, 복귀 주소에 접근하는 기법➡️ 함수의 매개 변수, 함수 반환 주소값, 지역 변수 등메모리의 스택 영역에 순서대로 저장되는 함수의 호출 정보를 스택 프레임이라고 한다.짚고 넘어가기 - 스택(1) Push스택에 Push를 하여 값을 넣으면 스택의 바닥(EBP)에서 스택 탑(ESP)을 향해 데이터가 쌓인다.(2) Pop스택에 Pop을 하여 값을 빼면 스택의 탑(ESP)에서 스택의 바닥(EBP)을 향해 데이터가 줄어든다.➡️ 즉, 데이터가 늘어날수록 낮은 주소에 저장이 된다.데이터가 늘어날수록 낮은 주소에 저장이 되는 이유는 커널(Kernel)과 만나지 않도록 하기 위함이다.함수의 호출 단계 함수가 사용할 매개 변수를 넣고 함수 시작 지점으로 점프한다. ➡️ 함수 호출 함수 내에서 사용할 스택 프레임을 설정한다. ➡️ 함수 프롤로그 함수의 내용을 수행한다. ➡️ 함수의 본체 수행을 끝내면 처음 호출한 지점으로 돌아가기 위해 스택을 복원한다. ➡️ 함수 에필로그스택 프레임의 구조PUSH EBP # 함수시작 (EBP를 사용하기 전에 기존의 값을 스택에 저장) MOV EBP, ESP # 현재의 ESP를 EBP에저장 # 함수 본체 ... # 여기서 ESP가 변경되더라도 EBP가 변경되지 않으므로 # 안전하게 로컬 변수와파라미터를 엑세스할 수 있음 MOV ESP, EBP # ESP를정리(함수 시작했을때의 값으로 복원시킴) POP EBP # 리턴되기 전에 저장해 놓았던 원래 EBP 값으로 복원RETN # 함수 종료(1) 함수 프롤로그PUSH EBP # 함수시작 (EBP를 사용하기 전에 기존의 값을 스택에 저장) MOV EBP, ESP # 현재의 ESP를 EBP에저장함수 수행을 마치면 다시 제자리로 돌아가기 위해 EBP의 값을 스택 PUSH 하여 저장해놓는다.EBP에 ESP를 저장해줌으로써 스택 프레임을 생성해준다.(2) 함수 에필로그MOV ESP , EBP # ESP를정리(함수 시작했을때의 값으로 복원시킴) POP EBP # 리턴되기 전에 저장해 놓았던 원래 EBP 값으로 복원RETN # 함수 종료함수 수행을 마치면 호출을 했던 지점으로 돌아가기 위해 처음 함수가 시작되었을 때의 값으로 복원시킨다.그다음, 프롤로그에서 PUSH 해놓았던 값을 다시 POP 하여 EBP에 넣어준다.실습하기C 코드#include &amp;lt;stdio.h&amp;gt;int sub(int a, int b) { int x = a, y = b; return (x - y);}int main() { int a = 5, b = 1; printf(&quot;%d\\n&quot;, sub(a, b)); return 0;}위의 C 코드를 디버거로 열어보았다.main() 함수sub() 함수(1) main() 함수 시작 &amp;amp; 스택 상태⬇️main() 함수를 실행했을 때의 스택 상태EBP의 값을 스택에 집어넣는 과정은 EBP가 이전에 가지고 있던 값을 스택에 백업해두기 위함이다.(2) main() 함수 스택 프레임 생성EBP에 ESP의 값을 옮겨줌으로써 서로 같은 값(012FFBB8)을 가지게 된다. 12FFBB8의 주소에는 12FFC00이라는 값이 저장되어 있다. 12FFC00은 main() 함수의 시작 때 EBP가 가지고 있던 초기 값이다.main() 함수가 끝날 때까지 EBP 값은 고정된다.따라서 스택에 저장된 함수의 매개 변수와 지역 변수들은 EBP를 통해 접근하게 된다.➡️ 2F10A0과 2F10A1 주소의 두 명령어를 통해 main() 함수에 대한 스택 프레임이 생성되었다.(3) 지역 변수 설정⬇️해당 C 코드int a = 5, b = 1;위의 C 코드를 보면 int형 변수 2개를 선언해 주었다.이 두 변수를 스택에 저장하려면 공간을 마련해주어야 하는데, int는 4바이트니 총 8바이트가 필요하다.이 과정을 ESP에 8을 빼줌으로써 필요한 공간을 확보해 주었다.이제 만들어둔 공간에 각각 5와 1을 넣어줄 차례이다.[EBP-8]의 주소에 5를 넣어주고, [EBP-4]의 주소에 1을 넣어준다.따라서 [EBP-8]은 변수 a이고, [EBP-4]는 변수 b임을 알 수 있다.⬇️지금까지 실행한 후의 스택 상태5와 1이 들어 있는 모습을 볼 수 있다.(4) sub() 함수 매개 변수 입력 &amp;amp; sub() 함수 호출⬇️해당 C 코드printf(&quot;%d\\n&quot;, sub(a, b));EAX에는 [EBP-4] 즉, 1을 옮겨주고 스택에 넣는다.ECX에는 [EBP-8] 즉, 5를 옮겨주고 스택에 넣는다.이는 변수 a, b를 스택에 넣는 것이다.주목할 내용은 파라미터가 C언어의 입력 순서와는 반대로 스택에 저장된다는 것이다.이를 “함수 파라미터의 역순 저장”이라고 한다⬇️지금까지 실행한 후의 스택 상태그 이후, sub() 함수를 호출한다.(5) sub() 함수 시작 &amp;amp; 스택 프레임 생성⬇️해당 C 코드int sub(int a, int b) {main() 함수와 마찬가지로 sub() 함수도 자신만의 스택 프레임을 생성한다.스택 프레임의 생성 과정은 main() 함수와 같다.⬇️지금까지 실행한 후의 스택 상태main() 함수에서 사용되던 EBP 값(12FFBB8)을 스택에 백업한 후 EBP는 12FFBA0로 새롭게 세팅된 것을 확인할 수 있다.(6) sub() 함수의 지역 변수 설정⬇️해당 C 코드 int a = 5, b = 1;sub() 함수의 지역 변수 x, y에 각각 매개 변수 a, b를 대입을 해주는 부분이다.이 역시 int형 변수 x와 y에 8바이트의 공간을 확보해준다.sub() 함수에서 스택 프레임이 생성되면서 EBP의 값이 변했다.따라서 [EBP+8], [EBP+C]가 각각 매개 변수 a, b를 가리킨다. (C는 16진수)[EBP-8], [EBP-4]는 각각 sub() 함수의 지역 변수 y, x를 의미한다.⬇️지금까지 실행한 후의 스택 상태(7) sub() 연산 return (x - y);위의 코드의 연산 부분이다.EAX에 [EBP-4] 즉, x를 옮겨준다.그다음, 5의 값이 들어있는 EAX에 y의 값이 들어있는 [EBP-8]를 빼준다.이 과정을 쉽게 연산으로 표현한다면5 - 1이 된다. 따라서 EAX의 값이 4가 되었다.(8) sub() 함수 스택 프레임 해제 &amp;amp; 함수 종료(리턴) return (x - y);}위의 코드의 해당하는 부분이다.EBP 값을 ESP에 대입해준다. 이는 sub() 함수가 시작될 때의 ESP값을 EBP에 넣어 두었다가 함수가 종료될 때 ESP를 원래대로 복원시키는 목적으로 사용하는 것이다.sub() 함수를 시작하면서 스택에 미리 저장해둔 EBP 값을 복원해준다.이 명령어는 앞의 PUSH EBP 명령에 대응하는 것이다.main() 함수의 EBP값을 복원함으로써 sub() 함수의 스택 프레임이 해제된다.⬇️지금까지 실행한 후의 스택 상태ESP가 12 FFBA4이고, 이 주소의 값은 F110C1이다.이 값은 CPU가 스택에 입력한 복귀 주소이다.RETN 명령어가 실행되면 스택에 저장된 복귀 주소로 리턴한다.⬇️지금까지 실행한 후의 스택 상태스택 상태를 확인해보면, sub() 함수를 호출하기 전의 상태로 되돌아왔다.(4) sub() 함수 매개 변수 입력 &amp;amp; sub() 함수 호출의 sub() 함수 호출 전의 스택 상태를 확인해보면완벽히 일치한다.프로그램은 이런 식으로 스택을 관리하기 때문에 함수의 호출이 아무리 많더라도 스택이 깨지지 않고 잘 유지되는 것이다.하지만 함수의 매개 변수, 복귀 주소값 등을 한 번에 보관하기 때문에 스택 버퍼 오버 플로우(Stack Buffer Overflow)에 취약하다.(9) sub() 함수 매개 변수 제거(스택 정리)sub() 함수에서 다시 main() 함수로 돌아왔다.‘ADD’ 명령으로 ESP에 8을 더하는 이유는 더 이상 사용하지 않는 sub() 함수에게 넘겨준 매개 변수인 a, b를 정리해주기 위함이다.‘ADD’ 명령 실행 전에 다음 아래의 스택 상태를 잘 보면 12FFBA8과 12FFBAC 주소에 5와 1, 즉 매개 변수 a, b가 있는 것을 알 수 있다.⬇️실행 후 스택 상태(10) printf() 함수 호출⬇️해당 C 코드 printf(&quot;%d\\n&quot;, sub(a, b));PUSH EAX : EAX에는 sub() 함수에서 저장된 리턴 값인 4가 들어있다.PUSH OFFSET … : “%d\\n”CALL stackstu.printf : printf() 함수 호출ADD ESP, 8 : 매개 변수 정리(11) 리턴 값 설정⬇️해당 C 코드 return 0;main() 함수의 리턴 값(0)을 설정해주는 코드이다.XOR은 배타적 논리합으로, 비교하는 값들이 서로 같으면 0을 반환한다.같은 레지스터를 비교했으므로 0이 된다.XOR을 사용하는 이유는 ‘MOV’ 명령어보다 실행 속도가 빠르기 때문에 레지스터를 초기화시킬 때 많이 사용된다.(11) 스택 프레임 해제 &amp;amp; main() 함수 종료⬇️해당 C 코드 return 0;}main() 함수의 스택 프레임을 해제한다.main() 함수의 지역 변수 역시 유효하지 않게 되었다.POP EBP까지 실행하고 나면 아래의 이미지와 같이 main() 함수가 시작할 때의 스택 모습과 현재의 스택 프레임이 동일해진다.이제 메인 함수가 ‘RETN’ 명령어를 실행 하면서 리턴 주소로 점프한다.그 이후에는 프로세스 종료 코드가 실행되며 최종적으로 프로그램이 종료가 된다. — ### 참고 자료이승원. 『리버싱 핵심 원리』. 인사이트, 2012[정보통신기술용어해설] - 스택 http://www.ktword.co.kr/test/view/view.php?m_temp1=1306" }, { "title": "SQL Injection ", "url": "/posts/SQL-injection/", "categories": "Web", "tags": "SQL, SQL injection", "date": "2022-08-28 00:00:00 +0000", "snippet": "SQL Injection1. SQL Injection 공격이란?SQL: DB에 명령 내릴 때 쓰는 언어Injection: 삽입임의의 SQL문을 삽입하고 실행시켜 데이터 베이스가 비정상적인 동작을 하도록조작하는 행위이다.2. SQL Injection 공격의 목적1. DB에 임의의 SQL명령 실행2. DB의 데이터를 추출3. 인증 우회4. DB 데이터 변조5. 악성 파일 업로드3. SQL Injection 공격의 종류1. Error based SQL Injection다양한 SQL Injection 공격 기법 중에서도 가장 많이 사용되며, 대중적으로 잘 알려진 공격 기법이다.SELECT * FROM users WHERE auth = &#39;admin&#39; AND id = &#39; id &#39;서버에서 요청을 보낸 사용자가 관리자 권한이 있는지 확인하기 위와 같은 sql문으로 확인한다고 했을 때,권한이 admin이고 올바른 id값을 가진 사용자가 있는지 조회해 결과가 나온다면 관리자로 인정받는다. 그러나 id의 인자로 아래와 같이 삽입 된다면,&#39; OR &#39;1&#39; = &#39;1싱글쿼터와 OR 1=1 라는 구문이 WHERE절을 모두 참으로 만들어 사실상 무조건적인 admin권한을 획득하는 것 이다.이 뿐만 아니라SELECT * FROM users WHERE auth = &#39;admin&#39; AND id = &#39;&#39;; DROP TABLE users; --&#39; ’; 으로 마무리 하고, DROP TABLE users; 새구문으로 사용자 테이블을 삭제하고 – 뒷 내용을 주석 처리한다면사용자 테이블을 전체 삭제하는 구문으로 서버 자체를 운영하지 못하게 할 수도 있는 공격 기법이다.2. Union based SQL Injection원래의 요청에 추가 쿼리를 삽입하여 정보를 얻어내는 기법으로 2개 이상의 쿼리를 요청하여 결과를 얻는 Union 명령어를 이용여 공격으로 하나의 테이블로 결과를 얻는다.단, Union 하는 두 테이블의 컬럼 수가 같아야 하고, 데이터 형이 같아야 한다.다음과 같은 게시글 검색 쿼리문에서SELECT * FROM Board WHERE title LIKE &#39;%INPUT%&#39; OR contents &#39;%INPUT%&#39;INPUT 안에&#39;UNION SELECT null,id,password FROM Users-- 를 넣어주게 되면 두 쿼리문이 합쳐져 하나의 테이블로 보여지게 된다.즉, Board 테이블의 id, password가 게시글과 함께 화면에 나타난다.3. Blind based SQL InjectionDB로부터 특정 데이터 전달받지 않고 즉, 정보를 직접적으로 알 수 없는 상황이더라도 참과 거짓 정보만을 통해 알아내는 기법이다.웹 서버 보안으로 인해 기존 SQL Injection 공격 기법을 통한 정보가 출력되지 않는 경우 해당 기법을 시도할 수 있다.4. Stored Procedure based SQL Injection일련의 쿼리들을 모아 하나의 함수처럼 사용하기 위한 기법으로 공격자는 시스템 권한을 획득 해야 하는 공격난이도가 높은 공격이지만 공격에 성공한다면, 서버에 직접적인 피해를 가할 수 있다.공격에 사용되는 대표적인 저장 프로시저는 MS-SQL 에 있는 xp_cmdshell로 윈도우 명령어를 사용할 수 있게 된다.4. SQL Injection 대응방안 입력값 검증 화이트리스트 방식으로 지정된 형식의 문자만 검증한다. 특수문자 등의 에러 발생 유무 확인한다. db_name()으로 DB명 추출 여부 확인한다. SQL 오류 발생시 에러 메세지 표시하지 않기 별도로 처리해주지 않을 경우 에러가 발생한 쿼리문과 함께 에러에 관한 내용을 반환한다. (이 때 테이블 명, 컬럼명, 쿼리문이 노출 될 수 있기 때문에 메세지가 표시되지 않도록 처리해 주어야 한다.) 서버 보안 최소 권한 유저로 DB를 운영한다. 목적에 따라 쿼리 권한을 수정한다. 지속적인 관리를 통해 신뢰할 수 있는 네트워크, 서버에 대해서만 접근 허용한다. 웹 방화벽을 사용한다. 5. SQL Injection 이해하기SQL Injection 공격을 이해하기 위한 간단한 실습을 진행해보자운영 체제는 kali linux이며, 웹 모의 해킹 실습 서버 dvwa를 통해 실습하였다. user ID를 입력하는 창이 존재한다. 1을 입력하였더니 ID가 1인 사용자의 정보가 출력되었다. 소스를 확인해보면 이 소스코드의 경우 user ID에 사용자가 입력한 값이$id라는 변수로 들어가기 때문에 직접 입력한 값으로 인해 sql 쿼리 문이 바뀌기 때문에 이는 sql 쿼리문을 조작할 수 있다는 의미이다. 위와 같이 입력하니 테이블의 모든 정보가 출력되었다. 이는 조건문이 항상 참이 되도록 입력됐기 때문이다. 다음으로 Union을 사용해보자면 위에서 설명한 것과 같이 Union은 두 테이블의 컬럼 수가 같아야 하기 때문에 컬럼 수를 확인해보기 위해 다음과 같이 입력해본다. select 뒤의 상수 값을 주게 되면 그것을 그대로 출력시킬 수 있다고 한다. 결과를 보니 컬럼의 수가 맞지 않다는 에러가 나왔다. 이렇게 select구문의 컬럼이 2개가 사용되었다는 것을 알 수 있다고 한다. 이제 DB정보를 알아보자면 1’union select schema_name,1 from information_schema.schemata #DB명 조회와 관련된 구문이다. 다음과 같이 모든 DB이름을 확인 할 수 있다.6. 참고https://noirstar.tistory.com/264 https://doh-an.tistory.com/27 버그잡는해커 유튜브" }, { "title": "FSB", "url": "/posts/FSB/", "categories": "Pwnable", "tags": "FSB", "date": "2022-08-27 00:00:00 +0000", "snippet": "Format String BugFormat StringFormat String이란 데이터의 형식을 정해주는 지정해주는 문자열이다. Format String Type Meaning %d int 정수 %f float 실수 %c char 문자 %s string 문자열 %u decimal 10진수 %x hexadecimal 16진수 %n int 출력된 문자의 개수 아래와 같이 printf 함수에서 자주 볼 수 있다.// 1번printf(&quot;%d&quot;, number);// 2번printf(number);위 두 코드는 number 변수를 출력하는 같은 기능을 수행하는 코드이다.코드만 보았을 때 두 코드에 차이점은 Format String 사용 여부이다.그렇다면 좀 더 코드 길이가 짧은 2번 코드가 좋은 코드라고 생각할 수 있다.하지만 2번 코드는 FSB 취약점을 가지고 있다.printf 함수printf 함수의 원형을 보자#include &amp;lt;stdio.h&amp;gt;int printf(const char * restrict format, ...);인자로 Format이 들어가는 것을 알 수 있다.만약 Format을 정하지 않으면 어떻게 될까?간단한 코드를 통해 확인해보자.// printf_test.c#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt;int main(int argc, char **argv){ char buf[100]; if(argc != 2) return 0; strcpy(buf, argv[1]); printf(buf); printf(&quot;\\n&quot;); return 0;}입력받은 두 번째 인자를 buf에 복사하고 출력하는 코드이다.abc를 입력해보자.printf 함수에 Format을 정하지 않았지만, 출력은 문제없이 작동한다.이번에는 Format String을 입력해보자. 오류는 일어나지 않았지만 %x를 사용해 변수와 상관없이 Stack에서 4byte만큼 pop해서 출력된 것을 볼 수 있다.AAAA를 입력 후 %x를 8번 출력했을 때 0x41414141 즉, AAAA가 저장되어있는 buf 배열인 것을 알 수 있다.또한 printf 함수의 인자와 buf 배열에 거리가 %x * 7 = 28byte인 것을 알 수 있다.Format String Bug ( FSB )Format String을 통해 현재 메모리 주소와 원하는 메모리 주소 등 메모리 구조를 추측할 수 있다.이를 통해 공격자들은 Format String Bug을 통해 메모리를 보거나 변조한다.메모리 변조를 위해서는 변조할 주소와 변조를 통해 이동할 주소를 알아야 한다.변조할 주소는 Debugging이나 Format String을 이용해 알아낼 수 있다.변조를 통해 이동할 주소 즉, RET 주소는 Debugging이나 환경변수를 통해 알아낼 수 있다.워게임으로 Format String Bug를 실습해보자. 실습 환경가상머신 : VMware workstation iso : exploit-exercises-protostar-2 ID : user PW : user 워게임 : Protostar 문제 : format2로그인 후 셸을 실행시켜준다.문제를 풀기 위해 /opt/protostar/bin 디렉터리로 이동하자.format2 문제를 풀어보자.우선 파일을 Debugging 하기 위해 tmp 디렉터리로 복사 후 이동하자.gdb를 통해 format2 파일을 Debugging 해보자.main 함수를 disassemble 해봤지만, vuln 함수 호출 외에 다른 코드가 없는 것을 보니 vuln 함수를 보도록 하자.vuln 함수는 입력받은 값을 512byte 변수에 저장하고 변수를 출력 후 0x80496e4 값이 64가 아니면 0x80496e4 값을 포함해 출력하고, 64가 맞다면 문자열만 출력한다.코드를 확인해보면 0x80496e4가 변조해야 할 target 변수에 주소인 것을 알 수 있다.다음으로는 %x를 이용해 printf와 buffer 사이 거리를 구해보자.%x를 4번 출력했을 때 buffer 배열이 나온다.printf와 buffer 사이 거리는 24byte인 것을 알 수 있다.이제 거리와 주소를 알아냈으니 FSB를 통해 target 변수를 변조해보자.메모리를 볼 때는 %x를 이용했다.메모리를 변조할 때는 %n을 이용할 것이다.%n은 출력된 바이트 수를 지정된 변수에 저장하는 Format String이다.%n을 사용해 target 변수에 주소가 들어있는 배열에 64를 저장하면 문제를 해결할 수 있다.target 변수가 변조되어 출력되는 것을 확인할 수 있다.하지만 64가 아니라 문제가 해결되지는 않았다.1byte를 출력하는 Format String인 %c를 이용해보자.target 변수가 64로 변조되어 문제가 해결된 것을 볼 수 있다.마무리하며Format String Bug는 메모리를 볼 수 있고, 메모리를 변조할 수 있어 다양한 공격에 활용될 수 있다.대응 방안으로는 FSB는 Format을 정해주지 않아서 발생하는 취약점이므로 코드를 작성할 때 정확한 Format String 지정이 필요하다.참고포맷스트링 공격(Format String Attack) - eli_ez3r Hacking Blog작은 실수에서 오는 취약점, 포맷 스트링 - Knowllipop 놀리팝Format Two :: Andrew Griffiths’ Exploit Education" }, { "title": "메모장 WriteFile() API 후킹", "url": "/posts/WriteFile_API_hooking/", "categories": "Reversing", "tags": "APIHooking", "date": "2022-08-26 00:00:00 +0000", "snippet": "후킹이란?리버싱에서 후킹은 정보를 가로채고, 실행 흐름을 변경하고, 원래와는 다른 기능을 제공하게 하는 기술입니다.후킹의 전체 프로세스 디스어셈블러/디버거를 이용하여 프그램의 구조와 동작 원리를 파악 버그 수정 또는 기능 개선에 필요한 훅(Hook) 코드를 개발 실행 파일과 프로세스 메모리를 자유롭게 조작하여 훅 코드 설치 여러가지 후킹 중 Win32 API를 후킹하는 기술을 API 후킹이라고 합니다.API란?Windows OS에서 시스템 자원(메모리, 파일, 네트워크 등)은 OS가 직접 관리하고 여러가지 이유(안정성, 보안, 효율 등)로 인해 사용자 애플리케이션의 직접적인 접근을 막아놓았습니다.사용자 애플리케이션이 시스템 자원을 사용하기 위해서는 시스템 커널에게 요청해야 하는데 요청 방법이 MS에서 제공한 Win32 API를 이용하는 것입니다.즉 API 함수 없이는 시스템 자원에 접근할 수 없기 때문에 의미 있는 프로그램을 만들어낼 수 없습니다.모든 프로세스에는 기본적으로 kernel32.dll이 로딩되며, kernel32.dll은 ntdll.dll을 로딩합니다. 특정 시스템 프로세스(smss.exe)의 경우 kernel32.dll을 로딩하지 않습니다.ntdll.dll은 유저 모드 애플리케이션의 코드에서 발생하는 시스템 자원에 대한 접근을 커널 모드에게 요청하는 역할을 수행합니다. kernel32.dll → ntdll.dllAPI 후킹이란?Win32 API 호출을 중간에서 가로채어 제어권을 얻어내는 것 API 호출 전/후에 사용자의 훅 코드를 실행시킬 수 있습니다. API에 넘어온 파라미터 혹은 API 함수의 리턴 값을 엿보거나 조작할 수 있습니다. API 호출 자체를 취소시키거나 사용자 코드로 실행 흐름을 변경시킬 수 있습니다. API 후킹의 테크 맵1. Method Object(what)API 후킹 방식(Method)에 대한 대분류로 API 후킹 방식은 작업 대상에 따라서 크게 static 방식과 dynamic 방식으로 나눌 수 있습니다. Static Dynamic 파일 대상 메모리 대상 프로그램 실행 전 후킹 프로그램 실행 후 후킹 최초 한 번만 후킹 실행될 때마다 후킹 특수한 상황에서 사용됨 일반적인 후킹 방법 Unhook 불가능 프로그램 실행 중에 Unhook 가능 2. Location(where)API 후킹을 위한 공략 위치1. IATIAT에 있는 API 주소를 후킹 함수로 변경하는 방법입니다.장점 : 구현 방법 쉬움단점 : IAT에 없는데 프로그램에서 사용되는 API들에 대해서 후킹 불가능(예 : DLL을 동적으로 로딩해서 사용하는 경우)2. Code프로세스 메모리에 매핑된 시스템 라이브러리(*.dll)에서 API의 실제 주소를 찾아가 코드를 직접 수정해버리는 방법입니다.이 방법이 가장 널리 사용되는 방법이며 다음과 같은 여러가지 다양한 옵션이 존재합니다. 시작 코드를 JMP 명령어로 패치 함수 일부 덮어쓰기 필요한 부분만 일부 변경 3. EATDLL의 EAT에 기록된 API의 시작 주소를 후킹 함수 주소로 변경하는 방법입니다.하지만 앞서 설명한 Code의 방법이 더 간단하고 강력하므로 EAT 수정 방법은 잘 사용되지 않습니다.3. Technique(How)후킹 대상 프로세스 메모리에 침투하여 후킹 함수를 설치하는 구체적 기법입니다.크게 디버그 기법과 인젝션 기법으로 나눌 수 있습니다.1. 디버그 기법대상 프로세스를 디버깅하면서 API 후킹을 하는 방법입니다.디버거는 디버깅을 당하는 프로세스인 디버기에 대한 모든 권한을 가지기 때문에, 디버기의 프로세스 메모리에 후킹 함수를 자유롭게 설치할 수 있습니다.여기서의 디버거는 일반적인 올리디버거, x64디버거, IDA와 같은 프로그램이 아니라 후킹을 위해 사용자가 직접 제작한 프로그램을 뜻합니다. 즉 프로그램에서 Debug API를 이용하여 대상 프로세스에 Attach하고 후킹 함수를 설치합니다. 그런 후에 실행을 재개하면 API 후킹이 이뤄집니다.2. 인젝션 기법인젝션 기법은 해당 프로세스 메모리 영역에 침투하는 기술로, 인젝션 대상에 따라 DLL 인젝션과 Code 인젝션으로 나눌 수 있습니다. DLL 인젝션 DLL 인젝션 기법은 대상 프로세스로 하여금 강제로 사용자가 원하는 DLL 파일을 로딩하게 만드는 기술입니다. 인젝션할 DLL에 미리 후킹 코드와 설치 코드를 만들고 DllMain()에서 설치 코드를 호출해주면, 인젝션 되는 순간 API 후킹이 완료됩니다. Code 인젝션 Code 인젝션 기법은 DLL 인젝션보다 좀 더 발전된 기술이며, 주로 악성코드에서 많이 사용됩니다. DLL 인젝션 처럼 완전한 형태의 PE Image가 아니라 실행 코드와 데이터만 인젝션된 상태에서 자신이 필요한 API를 직접 구해서 사용해야 하고 코드 내의 메모리 주소에 접근할 때 잘못된 주소를 액세스하지 않도록 주의해야 하기 때문에 Code 인젝션 기법의 구현 방법은 까다로운 편입니다. 4. API테크 맵에 소개된 방법들을 실제로 구현하기 위해 사용되는 API를 보여줍니다.테크 맵에 있는 API가 아니더라도 OpenProcess(), WriteProcessMemory(), ReadProcessMemory() API 들은 다른 프로세스 메모리에 접근하려고 할 때 항상 사용되는 API입니다.메모장 WriteFile() 후킹디버거 : 디버깅 프로그램디버기 : 디버기 당하는 프로그램디버거 프로세스로 등록되면 OS는 디버기에서 디버그 이벤트가 발생할 때 디버기의 실행을 멈추고 해당 이벤트를 디버거에게 통보합니다. 그리고 디버거는 해당 이벤트에 대해 적절한 처리를 한 후 디버기의 실행을 재개할 수 있습니다.디버그 이벤트 종류 EXCEPTION_DEBUG _EVENT CREATE_THREAD_DEBUG_EVENT CREATE_PROCESS_DEBUG_EVENT EXIT_THREAD_DEBUG_EVENT EXIT_PROCESS_DEBUG_EVENT LOAD_DLL_DEBUG_EVENT UNLOAD_DLL_DEBUG_EVENT OUTPUT_DEBUG_STRING_EVENT RIP_EVENT디버그 이벤트 중에서 디버깅에 관련된 이벤트는 첫 번째인 EXCEPTION_DEBUG_EVENT입니다.이와 관련된 예외 목록은 다음과 같습니다. EXCEPTION_ACCESS_VIOLATION EXCEPTION_ARRAY BOUNDS_EXCEEDED EXCEPTION_BREAKPOINT EXCEPTION_DATATYPE_MISALIGNMENT EXCEPTION_FLT_DENORMAL_OPERAND EXCEPTION_FLT_DIVIDE_BY_ZERO EXCEPTION_FLT_INEXACT_RESULT EXCEPTION_FLT_INVALID_OPERATION EXCEPTION_FLT_OVERFLOW EXCEPTION_FLT_STACK_CHECK EXCEPTION_FLT_UNDERFLOW EXCEPTION_ILLEGAL_INSTRUCTION EXCEPTION_IN_PAGE_ERROR EXCEPTION_INT_DIVIDE_BY_ZERO EXCEPTION_INT_OVERFLOW EXCEPTION_INV_ALID_DISPOSITION EXCEPTION_NONCONTINUABLE_EXCEPTION EXCEPTION_PRIV_INSTRUCTION EXCEPTION_SINGLE_STEP EXCEPTION_STACK_OVERFLOW이 예외 중 디버거가 반드시 처리해야 하는 예외는 EXCEPTION_BREAKPOINT 예외입니다.브레이크 포인트는 어셈블리 명령어로 ‘INT3’이며, IA-32 Instruction으로는 0xCC입니다.코드 디버깅 중 INT3 명령어를 만나면 실행이 중지되고 디버거에게 EXCEPTION_BREAKPOINT 예외 이벤트가 날아갑니다. 이때 디버거는 다양한 작업을 할 수 있습니다.디버그 기법을 통한 API 후킹 후킹을 원하는 프로세스에 attach하여 디버기를 만듦 훅 : API 시작 주소의 첫 바이트를 0xCC(INT3)로 변경 해당 API가 호출되면 제어는 디버거에게 넘어옴 원하는 작업 수행 언훅 : 0xCC(INT3)를 원래대로 복원 (API의 정상 실행을 위해) 해당 API 실행 훅 : 다시 0xCC로 바꿈 (지속적인 후킹을 위해) 디버기에게 제어를 되돌려줌Notepad.exe의 WriteFile() API 후킹파일이 저장될 때 입력된 파라미터를 조작하여 소문자로 입력된 내용을 전부 대문자로 변경하겠습니다.먼저 다음과 같이 notepad.exe를 실행시켜 PID가 1180인 것을 확인합니다.이제 다음과 같이 후킹 프로그램(hookdbg.exe)을 실행하고 실행 파라미터로 후킹할 프로세스의 PID를 받습니다.이렇게 hookdbg.exe를 실행하면 PID 1180에 해당하는 notepad 프로세스의 WriteFile() API 후킹이 시작됩니다.메모장에 아무 글자나 입력하고 저장을 해보겠습니다.저장을 마치면 notepad에는 아무 변화가 일어나지 않습니다. 하지만 notepad를 종료하고 hookdbg 프로그램을 확인해보면 다음과 같이 original string에는 처음 입력한 문자열이 나타나고 converted string에는 WriteFile() API 후킹에 의해 소문자가 대문자로 변경된 문자열이 나타납니다.그리고 저장된 writefilehook.txt 파일을 열면 실제로 모든 소문자가 대문자로 변경되어서 저장된 것을 확인할 수 있습니다.동작원리이 동작 원리는 notepad에서 뭔가를 파일에 저장하려면 kernel32!WriteFile() API를 사용할 것이라고 가정합니다.먼저 WriteFile() API MSDN을 확인해보겠습니다.WriteFile() API의 정의를 보면 두 번째 파라미터(lpBuffer)가 ‘쓰기 버퍼’이고 세 번째 파라미터(nNumberOfBytesToWrite)가 ‘써야 할 크기’입니다. 그리고 함수의 파라미터는 스택에 역순으로 저장됩니다.실제로 notepad를 디버깅하면서 확인해보겠습니다.먼저 올리디버거를 통해 notepad.exe 파일을 열고 kernel32!WriteFile() API를 찾아 BP를 설치한 후 F9를 눌러 실행시킵니다. 그리고 다음과 같이 아무 문자열이나 입력하고 파일을 저장합니다.그렇게 되면 다음과 같이 kernel32!WriteFile()에 멈추게 됩니다.여기서 F7을 눌러 다음과 같이 해당 함수 부분으로 진입합니다.현재 스택(ESP: 7FACC)에는 리턴 주소(01004C30)가 있고 ESP+8(7FAD8)에는 ‘쓰기버퍼’ 주소(CDE70)가 저장되어 있습니다.이를 확인하기 위해 덤프창에서 쓰기퍼버 주소(CDE70)으로 이동하면 다음과 같이 저장하려고 하는 문자열(Goodscp)이 보입니다.이 WriteFile() API를 후킹해서 쓰기 버퍼를 원하는 문자열로 덮어쓰면 디버그 방법을 사용한 API 후킹 성공입니다.hookdbg.exe#include &quot;windows.h&quot;#include &quot;stdio.h&quot;LPVOID g_pfWriteFile = NULL;CREATE_PROCESS_DEBUG_INFO g_cpdi;BYTE g_chINT3 = 0xCC, g_chOrgByte = 0;BOOL OnCreateProcessDebugEvent(LPDEBUG_EVENT pde){ // WriteFile() API 주소 구하기 g_pfWriteFile = GetProcAddress(GetModuleHandleA(&quot;kernel32.dll&quot;), &quot;WriteFile&quot;); // API Hook - WriteFile() // 첫 번째 byte 를 0xCC (INT 3) 으로 변경 // (orginal byte 는 백업) memcpy(&amp;amp;g_cpdi, &amp;amp;pde-&amp;gt;u.CreateProcessInfo, sizeof(CREATE_PROCESS_DEBUG_INFO)); ReadProcessMemory(g_cpdi.hProcess, g_pfWriteFile, &amp;amp;g_chOrgByte, sizeof(BYTE), NULL); WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, &amp;amp;g_chINT3, sizeof(BYTE), NULL); return TRUE;}BOOL OnExceptionDebugEvent(LPDEBUG_EVENT pde){ CONTEXT ctx; PBYTE lpBuffer = NULL; DWORD dwNumOfBytesToWrite, dwAddrOfBuffer, i; PEXCEPTION_RECORD per = &amp;amp;pde-&amp;gt;u.Exception.ExceptionRecord; // BreakPoint exception (INT 3) 인 경우 if( EXCEPTION_BREAKPOINT == per-&amp;gt;ExceptionCode ) { // BP 주소가 WriteFile() 인 경우 if( g_pfWriteFile == per-&amp;gt;ExceptionAddress ) { // #1. Unhook // 0xCC 로 덮어쓴 부분을 original byte 로 되돌림 WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, &amp;amp;g_chOrgByte, sizeof(BYTE), NULL); // #2. Thread Context 구하기 ctx.ContextFlags = CONTEXT_CONTROL; GetThreadContext(g_cpdi.hThread, &amp;amp;ctx); // #3. WriteFile() 의 param 2, 3 값 구하기 // 함수의 파라미터는 해당 프로세스의 스택에 존재함 // param 2 : ESP + 0x8 // param 3 : ESP + 0xC ReadProcessMemory(g_cpdi.hProcess, (LPVOID)(ctx.Esp + 0x8), &amp;amp;dwAddrOfBuffer, sizeof(DWORD), NULL); ReadProcessMemory(g_cpdi.hProcess, (LPVOID)(ctx.Esp + 0xC), &amp;amp;dwNumOfBytesToWrite, sizeof(DWORD), NULL); // #4. 임시 버퍼 할당 lpBuffer = (PBYTE)malloc(dwNumOfBytesToWrite+1); memset(lpBuffer, 0, dwNumOfBytesToWrite+1); // #5. WriteFile() 의 버퍼를 임시 버퍼에 복사 ReadProcessMemory(g_cpdi.hProcess, (LPVOID)dwAddrOfBuffer, lpBuffer, dwNumOfBytesToWrite, NULL); printf(&quot;\\n### original string ###\\n%s\\n&quot;, lpBuffer); // #6. 소문자 -&amp;gt; 대문자 변환 for( i = 0; i &amp;lt; dwNumOfBytesToWrite; i++ ) { if( 0x61 &amp;lt;= lpBuffer[i] &amp;amp;&amp;amp; lpBuffer[i] &amp;lt;= 0x7A ) lpBuffer[i] -= 0x20; } printf(&quot;\\n### converted string ###\\n%s\\n&quot;, lpBuffer); // #7. 변환된 버퍼를 WriteFile() 버퍼로 복사 WriteProcessMemory(g_cpdi.hProcess, (LPVOID)dwAddrOfBuffer, lpBuffer, dwNumOfBytesToWrite, NULL); // #8. 임시 버퍼 해제 free(lpBuffer); // #9. Thread Context 의 EIP 를 WriteFile() 시작으로 변경 // (현재는 WriteFile() + 1 만큼 지나왔음) ctx.Eip = (DWORD)g_pfWriteFile; SetThreadContext(g_cpdi.hThread, &amp;amp;ctx); // #10. Debuggee 프로세스를 진행시킴 ContinueDebugEvent(pde-&amp;gt;dwProcessId, pde-&amp;gt;dwThreadId, DBG_CONTINUE); Sleep(0); // #11. API Hook WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, &amp;amp;g_chINT3, sizeof(BYTE), NULL); return TRUE; } } return FALSE;}void DebugLoop(){ DEBUG_EVENT de; DWORD dwContinueStatus; // Debuggee 로부터 event 가 발생할 때까지 기다림 while( WaitForDebugEvent(&amp;amp;de, INFINITE) ) { dwContinueStatus = DBG_CONTINUE; // Debuggee 프로세스 생성 혹은 attach 이벤트 if( CREATE_PROCESS_DEBUG_EVENT == de.dwDebugEventCode ) { OnCreateProcessDebugEvent(&amp;amp;de); } // 예외 이벤트 else if( EXCEPTION_DEBUG_EVENT == de.dwDebugEventCode ) { if( OnExceptionDebugEvent(&amp;amp;de) ) continue; } // Debuggee 프로세스 종료 이벤트 else if( EXIT_PROCESS_DEBUG_EVENT == de.dwDebugEventCode ) { // debuggee 종료 -&amp;gt; debugger 종료 break; } // Debuggee 의 실행을 재개시킴 ContinueDebugEvent(de.dwProcessId, de.dwThreadId, dwContinueStatus); }}int main(int argc, char* argv[]){ DWORD dwPID; if( argc != 2 ) { printf(&quot;\\nUSAGE : hookdbg.exe &amp;lt;pid&amp;gt;\\n&quot;); return 1; } // Attach Process dwPID = atoi(argv[1]); if( !DebugActiveProcess(dwPID) ) { printf(&quot;DebugActiveProcess(%d) failed!!!\\n&quot; &quot;Error Code = %d\\n&quot;, dwPID, GetLastError()); return 1; } // 디버거 루프 DebugLoop(); return 0;}1. main()int main(int argc, char* argv[]){ DWORD dwPID; if( argc != 2 ) { printf(&quot;\\nUSAGE : hookdbg.exe &amp;lt;pid&amp;gt;\\n&quot;); return 1; } // Attach Process dwPID = atoi(argv[1]); if( !DebugActiveProcess(dwPID) ) { printf(&quot;DebugActiveProcess(%d) failed!!!\\n&quot; &quot;Error Code = %d\\n&quot;, dwPID, GetLastError()); return 1; } // 디버거 루프 DebugLoop(); return 0;}먼저 main() 함수를 보면 프로그램 실행 파라미터로 API 후킹하려는 프로세스의 PID를 받고 DebugActiveProcess()를 통해서 실행중인 프로세스에 Attach하여 디버깅을 시작합니다.DebugActiveProcess() MSDN을 확인해보면 다음과 같이 입력한 PID를 파라미터로 넘겨줍니다.그 다음 DebugLoop() 함수로 들어가서 디버기로부터 오는 디버그 이벤트를 처리합니다.2. DebugLoop()void DebugLoop(){ DEBUG_EVENT de; DWORD dwContinueStatus; // Debuggee 로부터 event 가 발생할 때까지 기다림 while( WaitForDebugEvent(&amp;amp;de, INFINITE) ) { dwContinueStatus = DBG_CONTINUE; // Debuggee 프로세스 생성 혹은 attach 이벤트 if( CREATE_PROCESS_DEBUG_EVENT == de.dwDebugEventCode ) { OnCreateProcessDebugEvent(&amp;amp;de); } // 예외 이벤트 else if( EXCEPTION_DEBUG_EVENT == de.dwDebugEventCode ) { if( OnExceptionDebugEvent(&amp;amp;de) ) continue; } // Debuggee 프로세스 종료 이벤트 else if( EXIT_PROCESS_DEBUG_EVENT == de.dwDebugEventCode ) { // debuggee 종료 -&amp;gt; debugger 종료 break; } // Debuggee 의 실행을 재개시킴 ContinueDebugEvent(de.dwProcessId, de.dwThreadId, dwContinueStatus); }}DebugLoop() 함수는 윈도우 프로시저 함수(WndProc)와 유사하게 동작합니다. 이 함수는 디버기로부터 발생하는 이벤트를 받아서 처리한 후 디버기의 실행을 재개합니다.이 함수에서 중요한 API는 WaitForDebugEvent() API입니다.WaitForDebugEvent() MSDN을 확인해보면 디버기로 부터 디버그 이벤트가 발생할 때까지 기다리는 함수입니다.DebugLoop() 함수 코드에서 디버그 이벤트가 발생하면 WaitForDebugEvent() API는 첫 번째 파라미터인 de 변수(DEBUG_EVENT 구조체 객체)에 해당 이벤트에 대한 정보를 설정한 후 즉시 리턴합니다.DEBUG_EVENT 구조체는 다음과 같습니다.디버그 이벤트는 9가지 종류가 있다고 했는데 DEBUG_EVENT.dwDebugEventCode 멤버에 9가지 이벤트 종류 중 하나가 세팅되며, 해당 이벤트 종류에 따라 적절한 DEBUG_EVENT.u(유니온) 멤버가 세팅됩니다.ContinueDebugEvent() API는 디버기의 실행을 재개하는 함수입니다.ContinueDebugEvent() MSDN을 확인해보면 마지막 파라미터인 dwContinueStatus는 DBG_CONTINUE 또는 DBG_EXCEPTION_NOT_HANDLED 중에서 하나의 값을 가질 수 있습니다.정상적으로 처리된 경우 DBG_CONTINUE로 세팅하고, 처리하지 못했거나 애플리케이션의 SEH(Structured Exception Handler)에서 처리하길 원할 때는 DBG_EXCEPTION_NOT_HANDLED로 세팅합니다.DebugLoop() 함수에서는 세 가지 디버그 이벤트를 처리합니다.1. EXIT_PROCESS_DEBUG_EVENT디버기 프로세스가 종료될 때 발생하는 이벤트로 위 코드에서 이벤트가 발생하면 디버거도 같이 종료합니다.2. CREATE_PROCESS_DEBUG_EVENTCREATE_PROCESS_DEBUG_EVENT의 이벤트 핸들러인 OnCreateProcessDebugEvent()는 디버기의 프로세스가 시작(혹은 Attach)될 때 호출됩니다.CREATE_PROCESS_DEBUG_INFO g_cpdi;BOOL OnCreateProcessDebugEvent(LPDEBUG_EVENT pde){ // WriteFile() API 주소 구하기 g_pfWriteFile = GetProcAddress(GetModuleHandleA(&quot;kernel32.dll&quot;), &quot;WriteFile&quot;); // API Hook - WriteFile() // 첫 번째 byte 를 0xCC (INT 3) 으로 변경 // (orginal byte 는 백업) memcpy(&amp;amp;g_cpdi, &amp;amp;pde-&amp;gt;u.CreateProcessInfo, sizeof(CREATE_PROCESS_DEBUG_INFO)); ReadProcessMemory(g_cpdi.hProcess, g_pfWriteFile, &amp;amp;g_chOrgByte, sizeof(BYTE), NULL); WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, &amp;amp;g_chINT3, sizeof(BYTE), NULL); return TRUE;}OnCreateProcessDebugEvent() 을 확인해보면 먼저 WriteFile() API의 시작 주소를 구합니다.여기서 주목해야 하는 것은 디버기 프로세스의 메모리 주소가 아니라 디버거 프로세스의 메모리 주소를 얻어서 사용하는 것입니다. Windows OS에서 System DLL인 경우 모든 프로세스에서 동일한 주소(가상 메모리 주소)에 로딩되므로 이렇게 해도 문제 없습니다.여기 나오는 g_cpdi는 전역변수로 선언하였고 CREATE_PROCESS_DEBUG_INFO 구조체 변수입니다.CREATE_PROCESS_DEBUG_INFO 구조체 hProcess 멤버(디버기 프로세스 핸들)를 이용하여 WriteFile() API를 후킹할 수 있습니다.디버그 방법에서 후킹 방법은 API 시작 위치에 브레이크 포인트를 설치하면 됩니다. 디버기의 프로세스 핸들을 가지고 있기 때문에 ReadProcessMemory(), WriteProcessMemory() API를 이용하여 디버기의 프로세스 메모리 공간에 자유롭게 읽기/쓰기 작업을 할 수 있습니다.3. EXCEPTION_DEBUG_EVENT - OnExceptionDebugEvent()가장 핵심적인 EXCEPTION_DEBUG_EVENT 이벤트 핸들러인 OnExceptionDebugEvent()는 디버기의 INT3 명령을 처리하게 될 함수입니다.BOOL OnExceptionDebugEvent(LPDEBUG_EVENT pde){ CONTEXT ctx; PBYTE lpBuffer = NULL; DWORD dwNumOfBytesToWrite, dwAddrOfBuffer, i; PEXCEPTION_RECORD per = &amp;amp;pde-&amp;gt;u.Exception.ExceptionRecord; // BreakPoint exception (INT 3) 인 경우 if( EXCEPTION_BREAKPOINT == per-&amp;gt;ExceptionCode ) { // BP 주소가 WriteFile() 인 경우 if( g_pfWriteFile == per-&amp;gt;ExceptionAddress ) { // #1. Unhook // 0xCC 로 덮어쓴 부분을 original byte 로 되돌림 WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, &amp;amp;g_chOrgByte, sizeof(BYTE), NULL); // #2. Thread Context 구하기 ctx.ContextFlags = CONTEXT_CONTROL; GetThreadContext(g_cpdi.hThread, &amp;amp;ctx); // #3. WriteFile() 의 param 2, 3 값 구하기 // 함수의 파라미터는 해당 프로세스의 스택에 존재함 // param 2 : ESP + 0x8 // param 3 : ESP + 0xC ReadProcessMemory(g_cpdi.hProcess, (LPVOID)(ctx.Esp + 0x8), &amp;amp;dwAddrOfBuffer, sizeof(DWORD), NULL); ReadProcessMemory(g_cpdi.hProcess, (LPVOID)(ctx.Esp + 0xC), &amp;amp;dwNumOfBytesToWrite, sizeof(DWORD), NULL); // #4. 임시 버퍼 할당 lpBuffer = (PBYTE)malloc(dwNumOfBytesToWrite+1); memset(lpBuffer, 0, dwNumOfBytesToWrite+1); // #5. WriteFile() 의 버퍼를 임시 버퍼에 복사 ReadProcessMemory(g_cpdi.hProcess, (LPVOID)dwAddrOfBuffer, lpBuffer, dwNumOfBytesToWrite, NULL); printf(&quot;\\n### original string ###\\n%s\\n&quot;, lpBuffer); // #6. 소문자 -&amp;gt; 대문자 변환 for( i = 0; i &amp;lt; dwNumOfBytesToWrite; i++ ) { if( 0x61 &amp;lt;= lpBuffer[i] &amp;amp;&amp;amp; lpBuffer[i] &amp;lt;= 0x7A ) lpBuffer[i] -= 0x20; } printf(&quot;\\n### converted string ###\\n%s\\n&quot;, lpBuffer); // #7. 변환된 버퍼를 WriteFile() 버퍼로 복사 WriteProcessMemory(g_cpdi.hProcess, (LPVOID)dwAddrOfBuffer, lpBuffer, dwNumOfBytesToWrite, NULL); // #8. 임시 버퍼 해제 free(lpBuffer); // #9. Thread Context 의 EIP 를 WriteFile() 시작으로 변경 // (현재는 WriteFile() + 1 만큼 지나왔음) ctx.Eip = (DWORD)g_pfWriteFile; SetThreadContext(g_cpdi.hThread, &amp;amp;ctx); // #10. Debuggee 프로세스를 진행시킴 ContinueDebugEvent(pde-&amp;gt;dwProcessId, pde-&amp;gt;dwThreadId, DBG_CONTINUE); Sleep(0); // #11. API Hook WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, &amp;amp;g_chINT3, sizeof(BYTE), NULL); return TRUE; } } return FALSE;}코드를 보면 처음 if문에서 EXCEPTION_BREAKPOINT 예외인지 체크합니다. 그 다음 if문에서 BP가 발생한 주소가 kernel32!WriteFile() 시작 주소와 같은지 체크합니다.WriteFile() 시작 주소는 OnCreateProcessDebugEvent()에서 미리 얻어 놓았으므로 이러한 두 가지 조건이 만족되면 아래의 1(Unhook) ~ 11(API Hook) 코드가 실행됩니다.1. Unhook(API 훅 제거 )//0xCC 로 덮어쓴 부분을 original byte 로 되돌림WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, &amp;amp;g_chOrgByte, sizeof(BYTE), NULL);먼저 언훅을 하는 이유는 소문자가 대문자로 변경되는 작업 이후에 WriteFile()을 정상적인 상태로 호출하기 위해서입니다. 언훅 방법은 0xCC(INT3)로 덮어쓴 부분을 원래 바이트로 변경해주면 됩니다.2. ThreadContext(쓰레드 컨텍스트) 구하기모든 프로그램은 프로세스 단위로 실행되고 프로세스의 실제 명령어 코드는 쓰레드 단위로 실행됩니다. Windows OS는 멀티쓰레드 기반이기 때문에 하나의 프로세스에서 여러 쓰레드가 동시에 실행될 수 있습니다.기존 쓰레드를 실행하면서 다음 실행에 필요한 중요한 정보는 CPU 레지스터 값 입니다. 그 쓰레드의 CPU 레지스터 정보를 저장하는 구조체가 CONTEXT 구조체 입니다.(쓰레드 하나당 CONTEXT 구조체 한 개)ctx.ContextFlags = CONTEXT_CONTROL;GetThreadContext(g_cpdi.hThread, &amp;amp;ctx);위 코드에 GetThreadContext() API를 호출하면 ctx 구조체 변수에 해당 쓰레드의 CONTEXT를 저장하는 것을 확인할 수 있습니다.3. WriteFile()의 param 2, 3 값 구하기// 함수의 파라미터는 해당 프로세스의 스택에 존재함// param 2 : ESP + 0x8// param 3 : ESP + 0xCReadProcessMemory(g_cpdi.hProcess, (LPVOID)(ctx.Esp + 0x8), &amp;amp;dwAddrOfBuffer, sizeof(DWORD), NULL);ReadProcessMemory(g_cpdi.hProcess, (LPVOID)(ctx.Esp + 0xC), &amp;amp;dwNumOfBytesToWrite, sizeof(DWORD), NULL);WriteFile()를 호출할 때 넘어온 파라미터 중에서 param 2(쓰기버퍼 주소), param 3(버퍼 크기)를 알아내야 합니다. 함수의 파라미터는 스택에 저장되므로 CONTEXT.Esp 멤버를 이용해서 각각의 값을 구합니다.4 ~ 8. 소문자 → 대문자 변환 후 덮어쓰기쓰기버퍼 주소와 크기를 구했으므로 이를 디버거 메모리 공간으로 읽어들인 후 소문자를 대문자로 변환합니다. 그리고 다시 원래 위치에 해당하는 디버기의 가상 메모리에 덮어쓰는 작업입니다.// #4. 임시 버퍼 할당lpBuffer = (PBYTE)malloc(dwNumOfBytesToWrite+1);memset(lpBuffer, 0, dwNumOfBytesToWrite+1);// #5. WriteFile() 의 버퍼를 임시 버퍼에 복사ReadProcessMemory(g_cpdi.hProcess, (LPVOID)dwAddrOfBuffer, lpBuffer, dwNumOfBytesToWrite, NULL);printf(&quot;\\n### original string ###\\n%s\\n&quot;, lpBuffer);// #6. 소문자 -&amp;gt; 대문자 변환for( i = 0; i &amp;lt; dwNumOfBytesToWrite; i++ ){ if( 0x61 &amp;lt;= lpBuffer[i] &amp;amp;&amp;amp; lpBuffer[i] &amp;lt;= 0x7A ) lpBuffer[i] -= 0x20;}printf(&quot;\\n### converted string ###\\n%s\\n&quot;, lpBuffer);// #7. 변환된 버퍼를 WriteFile() 버퍼로 복사WriteProcessMemory(g_cpdi.hProcess, (LPVOID)dwAddrOfBuffer, lpBuffer, dwNumOfBytesToWrite, NULL);// #8. 임시 버퍼 해제free(lpBuffer);9. Thread Context의 EIP를 WriteFile() 시작으로 변경하기CONTEXT에서 Eip 멤버를 WriteFile() 시작 위치로 변경합니다.EIP 현재 위치는 WriteFile() + 1(INT3)입니다.//(현재는 WriteFile() + 1 만큼 지나왔음)ctx.Eip = (DWORD)g_pfWriteFile;SetThreadContext(g_cpdi.hThread, &amp;amp;ctx);CONTEXT.Eip 멤버를 변경한 후 SetThreadContext() API를 호출합니다.10. 디버거 프로세스 진행이제 정상적인 WriteFile() API를 호출해야 하므로 ContinueDebugEvent() API를 호출하여 디버기 프로세스의 실행을 재개합니다.ContinueDebugEvent(pde-&amp;gt;dwProcessId, pde-&amp;gt;dwThreadId, DBG_CONTINUE);Sleep(0);CONTEXT.Eip를 WriteFile() 시작으로 되돌렸으므로 WriteFile() 호출이 진행됩니다.11. API 훅 설치WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, &amp;amp;g_chINT3, sizeof(BYTE), NULL);다음에도 후킹을 하기 위해 API 훅을 설치합니다.만약 API 훅을 설치하지 않으면 맨 처음 언훅되었기 때문에 WriteFile() API 후킹은 완전히 풀린상태가 돼 버립니다.참고 문헌[이승원] 리버싱 핵심원리 : 악성 코드 분석가의 리버싱 이야기reversecore · GitHub (리버싱 핵심원리 예제 GitHub)reversecore · Blog (리버싱 핵심원리 저자 블로그)" }, { "title": "[Flask] Bcrypt를 이용한 비밀번호 암호화 &amp; JWT 인증 기반 로그인", "url": "/posts/Flask_Bcrypt_JWT/", "categories": "Web", "tags": "Flask, Bcrypt, JWT", "date": "2022-08-23 00:00:00 +0000", "snippet": "Bcrypt비밀번호를 저장하는 목적으로 설계된 단방향 해시 함수이다. 단방향 해시 함수는 암호화는 가능하지만 복호화가 불가능하다. 회원가입 시 사용자가 입력한 비밀번호를 그대로 DB에 저장하는 것은 안전하지 않기 때문에 단방향 암호화를 거친 뒤 DB에 저장해야 한다.암호화가 왜 필요할까? 사용자가 입력한 비밀번호가 DB에 그대로 평문 저장된다면 DB가 해킹을 당할 경우 유저의 비밀번호가 그대로 노출된다. 외부 해킹이 아니더라도 내부 인력이 유저들의 비밀번호를 볼 수 있게 된다. 비밀번호를 단방향 암호화하여 DB에 저장하면 해커가 DB를 획득하더라도 복호화할 수 없기 때문에 평문 비밀번호 획득이 불가능하다. Bcrypt 암호화 진행 과정Bcrypt 비밀번호 암호화 실습HTMLregister.html&amp;lt;body&amp;gt; &amp;lt;form method=&quot;POST&quot; id=&quot;registerForm&quot;&amp;gt; &amp;lt;h2&amp;gt;회원가입&amp;lt;/h2&amp;gt; &amp;lt;br /&amp;gt; &amp;lt;div class=&quot;form-group&quot;&amp;gt; &amp;lt;label for=&quot;user_id&quot;&amp;gt;아이디&amp;lt;/label&amp;gt; &amp;lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;user_id&quot; name=&quot;user_id&quot; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;form-group&quot;&amp;gt; &amp;lt;label for=&quot;user_pw&quot;&amp;gt;비밀번호&amp;lt;/label&amp;gt; &amp;lt;input type=&quot;password&quot; class=&quot;form-control&quot; id=&quot;user_pw&quot; name=&quot;user_pw&quot; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&amp;gt;회원가입&amp;lt;/button&amp;gt; &amp;lt;/form&amp;gt;&amp;lt;/body&amp;gt;login.html&amp;lt;body&amp;gt; &amp;lt;form method=&quot;POST&quot; id=&quot;loginForm&quot;&amp;gt; &amp;lt;h2&amp;gt;로그인&amp;lt;/h2&amp;gt; &amp;lt;br /&amp;gt; &amp;lt;div class=&quot;form-group&quot;&amp;gt; &amp;lt;label for=&quot;user_id&quot;&amp;gt;아이디&amp;lt;/label&amp;gt; &amp;lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;user_id&quot; name=&quot;user_id&quot; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;form-group&quot;&amp;gt; &amp;lt;label for=&quot;user_pw&quot;&amp;gt;비밀번호&amp;lt;/label&amp;gt; &amp;lt;input type=&quot;password&quot; class=&quot;form-control&quot; id=&quot;user_pw&quot; name=&quot;user_pw&quot; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&amp;gt;로그인&amp;lt;/button&amp;gt; &amp;lt;/form&amp;gt;&amp;lt;/body&amp;gt;.env민감한 정보가 코드에 노출되는 것을 방지하기 위하여 민감 정보는 .env에 설정하고, app.py에서 os.getenv()를 통해 접근할 수 있도록 하였다.HOST=localhostUSER=mysql IDPASSWD=mysql ID의 암호DB=접속할 데이터베이스app.py python version 3.8.10 bcrypt version 3.2.2 from flask import Flask, render_template, redirect, request, make_responseimport osimport pymysqlimport bcryptapp = Flask(__name__)HOST = os.getenv(&#39;HOST&#39;)USER = os.getenv(&#39;USER&#39;)PASSWD = os.getenv(&#39;PASSWD&#39;)DB = os.getenv(&#39;DB&#39;)db = pymysql.connect(host=HOST, user=USER, passwd=PASSWD, db=DB, charset=&quot;utf8&quot;)@app.route(&#39;/&#39;, methods = [&#39;GET&#39;, &#39;POST&#39;])def register(): if request.method == &#39;GET&#39;: return render_template(&#39;register.html&#39;) else: cur = db.cursor() id = request.form.get(&#39;user_id&#39;) pw = request.form.get(&#39;user_pw&#39;) pw = pw.encode(&#39;utf-8&#39;) bcrypt_hash = bcrypt.hashpw(pw, bcrypt.gensalt()) decode_hash = bcrypt_hash.decode(&#39;utf-8&#39;) sql = &quot;INSERT INTO user (id, pw) values (&#39;%s&#39;,&#39;%s&#39;)&quot; % (id, decode_hash) cur.execute(sql) db.commit() cur.close() return redirect(&#39;/login&#39;)@app.route(&#39;/login&#39;, methods = [&#39;GET&#39;,&#39;POST&#39;])def login(): if request.method == &#39;GET&#39;: return render_template(&#39;login.html&#39;) else: id = request.form.get(&#39;user_id&#39;) pw = request.form.get(&#39;user_pw&#39;) cur = db.cursor() cur.execute(&#39;SELECT * FROM user WHERE id = %s&#39;, id) user_id = cur.fetchone() if user_id: cur.execute(&#39;SELECT pw FROM user WHERE id = %s&#39;, id) select_pw = cur.fetchone() user_pw_hash = select_pw[0] pw = pw.encode(&#39;utf-8&#39;) user_pw_hash = user_pw_hash.encode(&#39;utf-8&#39;) check = bcrypt.checkpw(pw, user_pw_hash) if check == True: resp = make_response(&#39;로그인 성공&#39;) return resp else: print(&quot;잘못된 비밀번호입니다.&quot;) else: print(&quot;존재하지 않는 계정입니다.&quot;) return render_template(&#39;login.html&#39;)if __name__==&quot;__main__&quot;: app.run(debug=True)문자열인 비밀번호를 bcrypt 라이브러리에서 사용하기 위해서는 utf-8 방식의 바이트 인코딩이 필요하다.pw = pw.encode(&#39;utf-8&#39;)인코딩한 비밀번호는 아래와 같이 해싱한다. gensalt()를 통해 salt 값을 생성하고, hashpw()에 비밀번호와 salt를 인자로 받아 암호화된 비밀번호를 생성한다.bcrypt_hash = bcrypt.hashpw(pw, bcrypt.gensalt())해싱된 비밀번호를 DB에 저장할 때는 현재 바이트인 해싱 비밀번호를 다시 유니코드로 바꿔줘야 한다. 이를 위해 인코딩 때와 동일하게 utf-8 방식으로 디코드 해준다.decode_hash = bcrypt_hash.decode(&#39;utf-8&#39;)회원가입을 마치고 DB 데이터를 확인해보면 다음과 같이 입력한 비밀번호가 bcrypt 암호화를 거쳐 저장된 것을 볼 수 있다.입력한 비밀번호와 DB에 저장되어 있는 bcrypt 암호화된 비밀번호가 일치하는지 확인한다. 일치 여부는 True / False로 반환된다.check = bcrypt.checkpw(pw, user_pw_hash)JWT (Json Web Token)사용자가 로그인을 하면 서버에서 발행해주는 토큰을 가지고 브라우저의 저장소에 토큰을 유지시키는 방식을 토큰 방식이라고 한다. 여기에서 사용되는 토큰이 바로 JWT이다.구조JWT는 위 그림과 같이 .으로 구분하여 3파트로 나누어진다. Header 토큰의 유형 해시 암호화 알고리즘 (HMAC, SHA256, RSA) Payload 토큰에 담을 클레임(claim) 정보 Payload에 담는 정보의 한 ‘조각’을 클레임이라 부르고, name / value의 한 쌍으로 이루어져 있다. 토큰에는 여러개의 클레임을 넣을 수 있다. 아이디, 비밀번호 등의 개인정보가 아닌 토큰의 발급일과 만료일자 등의 내용을 담는다. Signature Header와 Payload를 합친 후 서버에서 지정한 secret key로 암호화시켜 토큰을 변조하기 어렵게 만들어준다. 인증 과정세션 방식세션 방식은 서버의 메모리, 데이터베이스와 같은 서버의 자원들을 사용해서 사용자의 정보를 유지시키는 방식이다.세션 방식 인증 과정 사용자 로그인 서버에서는 계정정보를 읽어 사용자를 확인한 후, 사용자의 고유한 ID값을 부여하여 세션 저장소에 저장하고, 이와 연결되는 세션ID를 발행한다. 사용자는 서버에서 해당 세션ID를 받아 쿠키에 저장한 후, 인증이 필요한 요청마다 쿠키를 헤더에 실어 보낸다. 서버는 쿠키 내부의 세션ID를 통해 세션 내부에 일치하는 유저 정보를 가져와 처음 로그인한 유저가 맞는지 확인한다. 세션 방식의 문제점세션은 서버의 메모리 내부에 저장되기 때문에 세션의 양이 많아질 수록 메모리에 부하가 걸릴 수 있으며 쿠키와 세션의 정보가 유출되면 보안의 위험이 있다. 이러한 문제점을 해결하고자 고안된 것이 JWT이다.JWT 인증 기반 로그인 실습.envJWT 토큰 생성에는 payload와 secret key가 필요하다. 본인은 “RAINBOW”로 secret key를 설정하였다.HOST=localhostUSER=mysql IDPASSWD=mysql ID의 암호DB=접속할 데이터베이스SECRET_KEY=RAINBOWapp.py PyJWT version 2.4.0from flask import Flask, render_template, redirect, request, make_responsefrom datetime import timedeltafrom datetime import datetimeimport pymysqlimport bcryptimport jwtapp = Flask(__name__)HOST = os.getenv(&#39;HOST&#39;)USER = os.getenv(&#39;USER&#39;)PASSWD = os.getenv(&#39;PASSWD&#39;)DB = os.getenv(&#39;DB&#39;)SECRET_KEY = os.getenv(&#39;SECRET_KEY&#39;)db = pymysql.connect(host=HOST, user=USER, passwd=PASSWD, db=DB, charset=&quot;utf8&quot;)@app.route(&#39;/&#39;, methods = [&#39;GET&#39;, &#39;POST&#39;])def register(): if request.method == &#39;GET&#39;: return render_template(&#39;register.html&#39;) else: cur = db.cursor() id = request.form.get(&#39;user_id&#39;) pw = request.form.get(&#39;user_pw&#39;) pw = pw.encode(&#39;utf-8&#39;) bcrypt_hash = bcrypt.hashpw(pw,bcrypt.gensalt()) decode_hash = bcrypt_hash.decode(&#39;utf-8&#39;) sql = &quot;INSERT INTO user (id, pw) values (&#39;%s&#39;,&#39;%s&#39;)&quot; % (id, decode_hash) cur.execute(sql) db.commit() cur.close() return redirect(&#39;/login&#39;)@app.route(&#39;/login&#39;, methods = [&#39;GET&#39;,&#39;POST&#39;])def login(): if request.method == &#39;GET&#39;: return render_template(&#39;login.html&#39;) else: id = request.form.get(&#39;user_id&#39;) pw = request.form.get(&#39;user_pw&#39;) cur = db.cursor() cur.execute(&#39;SELECT * FROM user WHERE id = %s&#39;, id) user_id = cur.fetchone() if user_id: cur.execute(&#39;SELECT pw FROM user WHERE id = %s&#39;, id) select_pw = cur.fetchone() user_pw_hash = select_pw[0] pw = pw.encode(&#39;utf-8&#39;) user_pw_hash = user_pw_hash.encode(&#39;utf-8&#39;) check = bcrypt.checkpw(pw, user_pw_hash) if check == True: payload = { &#39;id&#39;: id, &#39;exp&#39;: datetime.utcnow() + timedelta(days=1) } access_token = jwt.encode(payload, SECRET_KEY, algorithm=&#39;HS256&#39;) resp = make_response(&#39;로그인 성공&#39;) return resp else: print(&quot;잘못된 비밀번호입니다.&quot;) else: print(&quot;존재하지 않는 계정입니다.&quot;) return render_template(&#39;login.html&#39;)if __name__==&quot;__main__&quot;: app.run(debug=True)payload를 설정해준다. exp는 토큰의 유효 시간을 나타낸다. 아래 코드는 토큰 만료 시간을 하루로 지정하였음을 의미한다.payload = { &#39;id&#39;: id, &#39;exp&#39;: datetime.utcnow() + timedelta(days=1)}jwt.encode() 함수에 설정한 payload와 secret key를 넣고 사용할 암호화 방식을 선택하여 토큰을 생성한다. JWT에 주로 사용되는 암호화 알고리즘으로는 HS256(대칭키 방식)과 RS256(공개키 방식)이 있으며, 해당 코드에서는 HS256 알고리즘을 사용하였다.access_token = jwt.encode(payload, SECRET_KEY, algorithm=&#39;HS256&#39;)참고비밀번호 암호화 Bcrypt (gensalt, hashpw, checkpw) : 네이버 블로그https://youngseokim-kr.github.io/backend/backend01/JWT (JSON Web Token) 이해하기와 활용 방안 - Opennaru, Inc.https://velog.io/@kingth/서버-인증-방식세션쿠키-토큰" }, { "title": "[전파해킹] HackRF 소개와 환경 구축 (우분투)", "url": "/posts/HackRF_Introduce/", "categories": "HackRF", "tags": "HackRF, 전파해킹", "date": "2022-08-22 00:00:00 +0000", "snippet": "1. HackRF One이란?“HackRF One”은 Great Scott Gadgets라는 사람이 만든 SDR 장치다. SDR(Software Defined Radio) 장치는 단어 그대로 소프트웨어로 제어할 수 있는 라디오(FM 라디오 보다 폭 넓은 개념) 장치를 말한다. 현재 한국에서는 23만원 정도에 팔고 있는 것으로 확인되는데 알리 익스프레스나 이베이 등 해외직구를 통하면 더욱 싸게 구매할 수 있다.해당 장치는 1Mhz ~ 6Ghz 주파수 대역에 전파를 송수신할 수 있으며, 반이중 통신(Half-Duplex)을 지원한다. 반이중 통신은 데이터를 송신할 때는 수신받지 못하고, 수신할 때는 송신하지 못하는 전송 방식이다. (무전기를 생각하면 편하다)참고로 가용 주파수가 제한적인 RTL-SDR 장치를 제외하면 전파를 송신할 수 있는 SDR 장치 중에서는 가장 저렴하다. HackRF의 상위 SDR 개념인 BladeRF 장치는 전이중 통신(Full-Duplex)을 지원해 송수신을 동시에 수행할 수 있지만 가격 차이가 2배 정도 난다.2. HackRF 도구 설치 (우분투)apt updateapt install -y hackrf libhackrf-dev libhackrf0터미널 창에 위와 같이 입력하여 HackRF 도구를 설치해준다.HackRF 장치를 PC에 연결하고 HackRF USB 디바이스를 VM 안으로 인식시켜 준다. 현재 버추얼박스 가상머신을 쓰고 있어 VMWARE에서는 또 다를 수 있지만 큰 맥락은 같다.‘hackrf_info’ 명령을 입력하면 정상적으로 HackRF One 장치가 인식된 모습을 볼 수 있다.3. GNU Radio 설치 (우분투)HackRF 도구로도 충분히 간단한 RF Replay Attack을 수행할 수 있지만, 조금 더 상세한 작업을 하기 위해서는 GNU Radio라는 도구가 필요하다.apt updateapt install -y gnuradio gr-osmosdr위와 같이 입력하여 GNU Radio 도구를 설치해준다. 처음에 GNU Radio만 설치했을 때 osmocom 모듈이 보이지 않아 삽질했던 기억이 있는데, gr-osmosdr 모듈을 apt로 같이 설치해주면 정상적으로 보이게 된다.‘gnuradio-companion’ 명령어를 입력하여 GNU Radio를 실행시킬 수 있다. 참고로 GNU Radio 프로그램은 root 권한으로 실행하는걸 추천한다. root 권한으로 실행하는 방법으로 하나는 ‘sudo -s’로 root 계정으로 전환한 후, 실행하는 방법이 있고, (위 사진과 같다) 하나는 명령 행 앞에 ‘sudo’를 붙여 ‘sudo gnuradio-companion’로 실행하는 방법이 있다.4. 참고 자료[원문] [HackRF One SDR장비 구매 및 소개]https://blog.naver.com/nms200299/221400205899 (본인 블로그)[원문] [HackRF 및 GNU Radio 우분투 리눅스 환경 구축]https://blog.naver.com/nms200299/222801381670 (본인 블로그)" }, { "title": "가상화폐 자산추적", "url": "/posts/Cryotocurrency_Tracing/", "categories": "Blockchain", "tags": "blockchain, bitcoin, utxo", "date": "2022-08-22 00:00:00 +0000", "snippet": "가상화폐 자산추적비트코인(bitcoin)은 블록체인(blockchain)을 기반으로 만들어진 암호화폐이다. 블록체인은 누구나 거래내역을 조회 및 보관할 수 있는 투명한 구조이지만, 거래 당사자의 인증 대신 문자열로 이루어진 거래 주소를 통해 거래가 진행되기 때문에 익명성을 띈다.이러한 익명성을 이용하여 암호화폐는 범죄에 이용되곤 한다. 2017년 갑자기 등장하여 전세계를 강타한 워너크라이의 랜섬웨어나, 불법 성착취물을 제작하여 유통한 N번방 사건에서도 대가로 암호화폐를 요구하였다.자산추적의 의미블록체인 네트워크는 익명성을 띄지만, 암호화폐를 이용하여 본인인증 또는 개인정보를 필요로 하는 물건구매 혹은 환전행위를 하게된다. 이 때문에 지속적인 추적을 할 경우, 소유주의 개인정보 확인이 가능해진다.암호화폐 자산추적에 대한 연구는 국내외로 지속되고있다. 본 포스팅에서는 ‘박순태, 신용희, 강홍구.(2020).사이버 범죄에 악용되는 암호화폐 불법거래 추적.정보과학회지,38(9),40-47.’ 해당 논문에서 제시한 방안을 참고 및 응용하여 ‘암호화폐 추적 솔루션‘을 제작하였다.UTXO란?UTXO는 Unspent Transaction output의 약자로, 미사용 트랜잭션 결과물을 의미한다.비트코인이나 큐텀의 경우에는 누군가에게 송금받은 금액을 UTXO로 저장한다.비트코인에서는 이더리움의 계좌잔고모델(Account Transaction Model)과 달리 계정이나 잔고가 없고, UTXO를 통해 코인의 존재여부를 확인한다.(그림1)_UTXO 이미지위 그림과 같이 사용자의 잔고 총액은, 가지고 있는 UTXO의 총합으로 이루어진다.이제 가상화폐의 거래과정을 통해 UTXO를 보다 더 정확히 알아보자.가상화폐에서의 거래과정(그림2)_가상화폐 거래과정그림1의 사용자 A가, 사용자 B에게 2BTC를 송금 완료한 경우의 그림이다. 블록체인에서의 거래는 Transaction(이하 TX)이라고 불리는 거래내역에 기록된다. TX입력부에는 이전에 가지고 있었던 5BTC에 대한 UTXO 정보가 기재되어, 다음 거래에서 이전의 거래내역을 역추적할 수 있다. (TX #1의 utxo정보는 그림1의 utxo #1을 가리키고 있다.)(그림3)_역추적 흐름도TX를 나열하면 다음과 같은 그림으로 나타낼 수 있다. 이를 통해 마지막 트랜잭션부터 이전의 거래내역까지 거슬러 올라갈 수 있다. 위 과정을 전처리 후 작업을 거쳐 정방향으로 암호화폐의 흐름을 추적할 수 있는 솔루션을 제작하고자 한다.개발 구조도개발 구조도는 다음과 같다(그림4)_개발 구조도 블록체인 네트워크(해당 글에서는 비트코인 테스트 네트워크를 사용하였다.)에서 ‘TX 수집기’가 모든 TX와 UTXO 정보에 관하여 수집한다. 수집한 TX와 UTXO정보를 json형식으로 TX DB에 저장한다. 사용자가 추적하길 원하는 TX정보를 입력한다. 탐색기에 의하여 해당 TX이후의 거래내역을 추적하여 결과물을 출력한다.TX수집기 개발(그림5)_TX수집기 원리TX수집기와 탐색기는 모두 Go언어로 작성되었다.먼저 TX수집기는 Bitcoin API를 활용하여, 블록체인 네트워크 내의 모든 TX를 수집한다. 이후 해당 TX의 이전 거래내역인 UTXO 정보 또한 수집하여, 데이터베이스에 저장시켜 놓는다.블록체인 네트워크 내의 TX수집func loadblock(blocknumber string) []string { var blockhash []byte blockhash = nodecmd(&quot;getblockhash&quot;, blocknumber) //원하는 블록의 해시값을 가져옴 var blockinfo []byte blockinfo = nodecmd(&quot;getblock&quot;, string(blockhash)) //해당 블록의 정보를 불러옴 matchtxs, _ := regexp.Compile(&quot;\\\\[[^]]*\\\\]&quot;) txs := matchtxs.FindString(string(blockinfo)) matchtx, _ := regexp.Compile(&quot;[^\\&quot;]*&quot;) txlist := matchtx.FindAllString(txs, -1) //정규표현식 파싱을 통하여 블록의 트랜잭션 값만 불러옴 txlist = txlist[1:] //파싱을 통한 값 첫번째에 공백이 들어가 있어서 해당부분 제거 return txlist}UTXO 정보 수집 후, json형식으로 저장func savetx(txlist []string, blocknumber string) { data := make([]TxData, (len(txlist) / 2)) for i := 0; i &amp;lt; (len(txlist) / 2); i++ { getrawtx := string(nodecmd(&quot;getrawtransaction&quot;, txlist[2*i])) //getrawtransaction 으로 해당 트랜잭션의 정보를 hex값으로 얻어옴 txinfo := string(nodecmd(&quot;decoderawtransaction&quot;, getrawtx)) //얻어온 hex값 해독 vinmatch, _ := regexp.Compile(&quot;\\\\[[^]]*\\\\]&quot;) vin := vinmatch.FindString(txinfo) //vin 파싱 pointermatch, _ := regexp.Compile(&quot;[a-z0-9]{63,64}&quot;) pointer := pointermatch.FindAllString(vin, -1) data[i].Info = txlist[2*i] data[i].Pointer = pointer } doc, _ := json.Marshal(data) // data를 JSON 문서로 변환 err2 := ioutil.WriteFile(&quot;../txinfo/&quot;+blocknumber+&quot;.json&quot;, doc, os.FileMode(0644)) // articles.json 파일에 JSON 문서 저장 if err2 != nil { fmt.Println(err2) }}위의 두 코드는 TX수집기의 코드 일부이다. 블록체인 네트워크 내의 TX와 UTXO정보를 모두 불러와서, 정규 표현식을 통한 파싱을 진행한다. 이후, TX DB에 저장시키는 역할을 한다.탐색기 개발(그림6)_탐색기 원리위의 그림과 같이 사용자 A는 추적하고 싶은 TX값을 입력하게 된다. 값을 입력받은 탐색기는, TX DB에 있는 UTXO정보를 탐색하여 일치하는 값을 찾는다. 이후 탐색한 UTXO값과 대응하는 TX값을 반환한다.TX DB에 들어있는 TX에 대응하는 UTXO정보에는 이전 거래를 가리키고 있기 때문에, UTXO정보에 대응하는 TX값은 다음 거래를 가리킨다.func searchnexttx(searchtxinfo string, blocknumber int, root *gtree.Node) { var list []string for s := 1; s &amp;lt; blocknumber; s++ { stostring := strconv.Itoa(s) b, err := ioutil.ReadFile(&quot;../txinfo/&quot; + stostring + &quot;.json&quot;) if err != nil { fmt.Println(err) } var data []TxData json.Unmarshal(b, &amp;amp;data) for t := 0; t &amp;lt; len(data); t++ { for u := 0; u &amp;lt; len(data[t].Pointer); u++ { if data[t].Pointer[u] == searchtxinfo { list = append(list, data[t].Info) } } } } if list != nil { for i := 0; i &amp;lt; len(list); i++ { newRoot := root.Add(list[i]) searchnexttx(list[i], blocknumber, newRoot) } }}위의 코드는 입력한 값과 대응되는 UTXO를 찾고, 해당 UTXO값에 대응되는 TX값을 반환하는 코드이다. 이후 재귀함수를 통해서 마지막 트랜잭션에 도달하여, 더 이상 거래내역이 존재하지 않을 때까지 거래를 추적한다.출력결과테스트 네트워크 환경 구성 후 트랜잭션 ‘742718dc9625c6aac6eca4b57d93051208540cd3d65773a41131ce77eee16291’에 관한 추적을 해보았다.출력결과 784c7115114ff74d49ad2624f4d520c2f60fb3ebb8480834c7c51c1427dcffa2└── 9a1573f71f7ca2b32b17b6d3b09e5634258fbedac65552ac3a90eb5b1d40a880 ├── 55d91986122006d4537fee88f5ed042e5cd23141dc3db5765d2e72a96ef1f851 │ ├── dcd7c5f1e3fb2af005b3e48e52d24a73dbdb1c0a6fcd233e7f5ae1f1b699cf09 │ │ ├── 9dca1dfcd68b2536747776de7ae38b13873f18605a5bad42cd54ec2f4adfde5f │ │ └── 46b9f166584cef2e8d6e71274831a2206c89ed852b60f7149799a8f2d4100071 │ └── df44f4c5e58ba2bdb721eadf6bce0203d880282a020bb0ee623193ea7246df38 └── 1059678796083d29953aa7771d70a4e36dadd5d698de080fcea8ef8d84fcb15a6e71274831a2206c89ed852b60f7149799a8f2d4100071 │ └── df44f4c5e58ba2bdb721eadf6bce0203d880282a020bb0ee623193ea7246df38 └── 1059678796083d29953aa7771d70a4e36dadd5d698de080fcea8ef8d84fcb15a └── effdab52c683c703af3848386f47c4e185dc1de67031a91dab4abe753f623c68 └── 742718dc9625c6aac6eca4b57d93051208540cd3d65773a41131ce77eee16291다음과 같이 트리구조로 저장되어, 이후 거래내역을 추적할 수 있는 것을 알 수 있다.글을 마치며이번 포스팅에서는 비트코인이나 퀀텀에서 사용하는 UTXO정보가 트랜잭션에 남는다는 것을 활용하여, 자산추적 솔루션 개발까지 진행하였다. 본 포스팅이 생소할 수 있는 블록체인 보안에 관심이 있는 분들께, 도움이 되었으면 좋겠다.중부대학교 보안동아리 SCP 유재겸참고 문헌‘박순태, 신용희, 강홍구.(2020).사이버 범죄에 악용되는 암호화폐 불법거래 추적.정보과학회지,38(9),40-47.’" } ]
